# Combined Text Files
# Generated: 2025-03-02T17:13:52.947023


================================================================================
FILE: combined_text_files.txt
================================================================================

# Combined Text Files
# Generated: 2025-03-02T17:13:29.586087


================================================================================
FILE: background/background.js
================================================================================

import "./messageRouter.js";

chrome.runtime.onInstalled.addListener(() => {
    console.log("Claude Downloader Extension Installed.");
});


================================================================================
FILE: background/apiFetchService.js
================================================================================

export async function fetchChatData(details) {
    const headers = details.requestHeaders.reduce((acc, h) => {
        acc[h.name] = h.value;
        return acc;
    }, {});

    headers["X-Own-Request"] = "true";

    const resp = await fetch(details.url, {
        method: details.method,
        headers,
        credentials: "include",
    });

    return resp.ok ? resp.json() : null;
}


================================================================================
FILE: background/messageRouter.js
================================================================================

import { handleDownloadArtifacts } from "./artifactService.js";

chrome.runtime.onMessage.addListener((request, sender) => {
    switch (request.action) {
        case "downloadArtifacts":
            handleDownloadArtifacts(request, sender);
            break;
        default:
            console.warn(`Unhandled action: ${request.action}`);
    }
});


================================================================================
FILE: background/storageService.ts
================================================================================

import { ArtifactSettings, DEFAULT_SETTINGS } from '../models/settings';
import { LoggerService } from './loggerService';

/**
 * Service for interacting with Chrome storage
 */
export class StorageService {
    private static instance: StorageService;
    private readonly logger = LoggerService.getInstance();

    private constructor() {
        // Private constructor for singleton
    }

    /**
     * Get the singleton instance of the storage service
     */
    public static getInstance(): StorageService {
        if (!StorageService.instance) {
            StorageService.instance = new StorageService();
        }
        return StorageService.instance;
    }

    /**
     * Get the user settings from storage or return defaults
     */
    public async getSettings(): Promise<ArtifactSettings> {
        try {
            const result = await chrome.storage.sync.get('artifactSettings');

            if (result.artifactSettings) {
                // Handle potential schema upgrades here
                const storedSettings = result.artifactSettings as ArtifactSettings;
                const currentVersion = DEFAULT_SETTINGS.version;

                if (storedSettings.version !== currentVersion) {
                    this.logger.info(`Migrating settings from version ${storedSettings.version} to ${currentVersion}`);
                    return this.migrateSettings(storedSettings, currentVersion);
                }

                return storedSettings;
            } else {
                // No settings found, save and return defaults
                await this.saveSettings(DEFAULT_SETTINGS);
                return DEFAULT_SETTINGS;
            }
        } catch (error) {
            this.logger.error('Failed to get settings', error);
            return DEFAULT_SETTINGS;
        }
    }

    /**
     * Save settings to storage
     */
    public async saveSettings(settings: ArtifactSettings): Promise<boolean> {
        try {
            await chrome.storage.sync.set({ artifactSettings: settings });
            this.logger.debug('Settings saved successfully');
            return true;
        } catch (error) {
            this.logger.error('Failed to save settings', error);
            return false;
        }
    }

    /**
     * Update specific settings and save
     */
    public async updateSettings(partialSettings: Partial<ArtifactSettings>): Promise<boolean> {
        try {
            const currentSettings = await this.getSettings();
            const updatedSettings = {
                ...currentSettings,
                ...partialSettings
            };
            return this.saveSettings(updatedSettings);
        } catch (error) {
            this.logger.error('Failed to update settings', error);
            return false;
        }
    }

    /**
     * Migrate settings from a previous version
     */
    private migrateSettings(oldSettings: ArtifactSettings, newVersion: number): ArtifactSettings {
        // Start with current defaults
        const newSettings = { ...DEFAULT_SETTINGS };

        // Copy over as many properties as possible from old settings
        Object.keys(newSettings).forEach(key => {
            if (key in oldSettings && key !== 'version') {
                (newSettings as any)[key] = (oldSettings as any)[key];
            }
        });

        // Set the new version
        newSettings.version = newVersion;

        // Save the migrated settings
        this.saveSettings(newSettings).catch(error => {
            this.logger.error('Failed to save migrated settings', error);
        });

        return newSettings;
    }

    /**
     * Save an artifact to local storage (used for stitching)
     */
    public async saveArtifact(key: string, data: any): Promise<void> {
        try {
            await chrome.storage.local.set({ [key]: data });
            this.logger.debug(`Artifact saved: ${key}`);
        } catch (error) {
            this.logger.error(`Failed to save artifact: ${key}`, error);
            throw error;
        }
    }

    /**
     * Get an artifact from local storage
     */
    public async getArtifact(key: string): Promise<any> {
        try {
            const result = await chrome.storage.local.get(key);
            return result[key];
        } catch (error) {
            this.logger.error(`Failed to get artifact: ${key}`, error);
            throw error;
        }
    }

    /**
     * Remove an artifact from local storage
     */
    public async removeArtifact(key: string): Promise<void> {
        try {
            await chrome.storage.local.remove(key);
            this.logger.debug(`Artifact removed: ${key}`);
        } catch (error) {
            this.logger.error(`Failed to remove artifact: ${key}`, error);
            throw error;
        }
    }

    /**
     * Clear all stored artifacts (but keep settings)
     */
    public async clearArtifacts(): Promise<void> {
        try {
            await chrome.storage.local.clear();
            this.logger.info('All artifacts cleared from storage');
        } catch (error) {
            this.logger.error('Failed to clear artifacts', error);
            throw error;
        }
    }
}


================================================================================
FILE: background/downloadService.js
================================================================================

const downloadService = {
    async downloadZip(blob, filename) {
        const url = URL.createObjectURL(blob);
        chrome.downloads.download({ url, filename, saveAs: true }, () => {
            URL.revokeObjectURL(url);
        });
    },
};

export default downloadService;


================================================================================
FILE: background/artifactService.js
================================================================================

import storageService from "./storageService.js";
import downloadService from "./downloadService.js";
import { extractArtifacts } from "../shared/artifactExtractor.js";
import { getUniqueFileName } from "../shared/filenameHelper.js";
import { createZip } from "../shared/zipCreator.js";

export async function handleDownloadArtifacts(request, sender) {
    const payload = await storageService.getChatPayload(request.uuid);
    if (!payload) {
        notifyTab(sender.tab.id, false, "No payload found, try refreshing.");
        return;
    }

    const artifacts = [];
    const usedNames = new Set();

    payload.chat_messages.forEach((message, index) => {
        if (message.sender !== "assistant" || !message.text) return;

        const extracted = extractArtifacts(message.text);
        extracted.forEach((artifact) => {
            artifacts.push({
                filename: getUniqueFileName(
                    artifact.title,
                    artifact.language,
                    index,
                    usedNames,
                    request.useDirectoryStructure
                ),
                content: artifact.content,
            });
        });
    });

    if (!artifacts.length) {
        notifyTab(sender.tab.id, false, "No artifacts in this conversation.");
        return;
    }

    const zipBlob = await createZip(artifacts);
    await downloadService.downloadZip(zipBlob, `${payload.name}.zip`);
    notifyTab(sender.tab.id, true, `${artifacts.length} artifacts downloaded.`);
}

function notifyTab(tabId, success, message) {
    chrome.tabs.sendMessage(tabId, {
        action: "artifactsProcessed",
        success,
        message,
    });
}


================================================================================
FILE: background/index.ts
================================================================================

import { LoggerService } from '../shared/services/loggerService';
import { StorageService } from '../shared/services/storageService';
import { ArtifactService } from './services/artifactService';
import { DownloadService } from './services/downloadService';
import { MessageRouter } from './services/messageRouter';
import { ApiService } from './services/apiService';

/**
 * Main entry point for the background script
 */
class Background {
    private readonly logger = LoggerService.getInstance();
    private readonly storageService = StorageService.getInstance();
    private readonly artifactService = ArtifactService.getInstance();
    private readonly downloadService = DownloadService.getInstance();
    private readonly apiService = ApiService.getInstance();
    private readonly messageRouter = MessageRouter.getInstance();

    constructor() {
        this.init().catch(error => {
            console.error('Background: Initialization error', error);
        });
    }

    /**
     * Initialize the background script
     */
    private async init(): Promise<void> {
        try {
            this.logger.info('Background: Initializing');

            // Load settings
            await this.storageService.getSettings();

            // Initialize services
            this.messageRouter.init();
            this.artifactService.init();
            this.downloadService.init();
            this.apiService.init();

            // Set up extension icon click handler
            chrome.action.onClicked.addListener(this.handleActionClick.bind(this));

            this.logger.info('Background: Initialization complete');
        } catch (error) {
            this.logger.error('Background: Initialization failed', error);
        }
    }

    /**
     * Handle extension icon click
     */
    private async handleActionClick(tab: chrome.tabs.Tab): Promise<void> {
        if (!tab.id) return;

        try {
            // Check if on Claude site
            const url = tab.url || '';
            if (!url.includes('claude.ai') && !url.includes('anthropic.com')) {
                await chrome.tabs.create({ url: 'https://claude.ai/' });
                return;
            }

            // Send message to show settings
            chrome.tabs.sendMessage(tab.id, { action: 'showSettings' });
        } catch (error) {
            this.logger.error('Background: Error handling action click', error);
        }
    }
}

// Initialize background script
new Background();


================================================================================
FILE: background/services/downloadService.ts
================================================================================

import { ArtifactFile } from '../../shared/models/artifact';
import { LoggerService } from '../../shared/services/loggerService';
import { ZipCreator } from '../../shared/utils/zipCreator';

/**
 * Service for downloading artifacts
 */
export class DownloadService {
    private static instance: DownloadService;
    private readonly logger = LoggerService.getInstance();

    private constructor() {
        // Private constructor for singleton
    }

    /**
     * Get the singleton instance of the download service
     */
    public static getInstance(): DownloadService {
        if (!DownloadService.instance) {
            DownloadService.instance = new DownloadService();
        }
        return DownloadService.instance;
    }

    /**
     * Initialize the download service
     */
    public init(): void {
        this.logger.debug('DownloadService: Initialized');
    }

    /**
     * Download artifacts as a ZIP file
     */
    public async downloadArtifactsAsZip(files: ArtifactFile[]): Promise<string> {
        try {
            if (files.length === 0) {
                throw new Error('No artifacts to download');
            }

            // Create ZIP file
            const zipBlob = await ZipCreator.createZip(files);

            // Create a download URL
            const url = URL.createObjectURL(zipBlob);

            // Generate filename
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
            const filename = `claude-artifacts-${timestamp}.zip`;

            // Trigger download
            await this.downloadFile(url, filename);

            // Clean up
            setTimeout(() => URL.revokeObjectURL(url), 60000);

            return filename;
        } catch (error) {
            this.logger.error('DownloadService: Error downloading artifacts as ZIP', error);
            throw error;
        }
    }

    /**
     * Download a single artifact file
     */
    public async downloadSingleArtifact(file: ArtifactFile): Promise<string> {
        try {
            // Create a Blob from the content
            const blob = typeof file.content === 'string'
                ? new Blob([file.content], { type: 'text/plain' })
                : file.content;

            // Create a download URL
            const url = URL.createObjectURL(blob);

            // Trigger download
            await this.downloadFile(url, file.filename);

            // Clean up
            setTimeout(() => URL.revokeObjectURL(url), 60000);

            return file.filename;
        } catch (error) {
            this.logger.error('DownloadService: Error downloading single artifact', error);
            throw error;
        }
    }

    /**
     * Helper to trigger a file download
     */
    private async downloadFile(url: string, filename: string): Promise<void> {
        return new Promise<void>((resolve, reject) => {
            chrome.downloads.download({
                url,
                filename,
                saveAs: false
            }, (downloadId) => {
                if (chrome.runtime.lastError) {
                    reject(chrome.runtime.lastError);
                } else {
                    resolve();
                }
            });
        });
    }
}


================================================================================
FILE: background/services/artifactService.ts
================================================================================

import { Artifact, ArtifactFile } from '../../shared/models/artifact';
import { LoggerService } from '../../shared/services/loggerService';
import { StorageService } from '../../shared/services/storageService';
import { FilenameHelper } from '../../shared/utils/filenameHelper';

/**
 * Service for managing artifacts
 */
export class ArtifactService {
    private static instance: ArtifactService;
    private readonly logger = LoggerService.getInstance();
    private readonly storageService = StorageService.getInstance();

    private constructor() {
        // Private constructor for singleton
    }

    /**
     * Get the singleton instance of the artifact service
     */
    public static getInstance(): ArtifactService {
        if (!ArtifactService.instance) {
            ArtifactService.instance = new ArtifactService();
        }
        return ArtifactService.instance;
    }

    /**
     * Initialize the artifact service
     */
    public init(): void {
        this.logger.debug('ArtifactService: Initialized');
    }

    /**
     * Process artifacts for download
     */
    public async processArtifacts(
        artifacts: Artifact[],
        stitchArtifacts: boolean,
        flatStructure: boolean
    ): Promise<ArtifactFile[]> {
        try {
            // Get settings
            const settings = await this.storageService.getSettings();

            // Stitch artifacts if requested
            let processedArtifacts = artifacts;
            if (stitchArtifacts) {
                // Implementation in artifactExtractor.ts
                // processedArtifacts = ArtifactExtractor.stitchArtifacts(artifacts);
            }

            // Convert artifacts to files
            const files: ArtifactFile[] = [];

            for (const artifact of processedArtifacts) {
                // Generate filename
                const filename = FilenameHelper.getFilename(
                    artifact,
                    settings.includeTimestampInFilename,
                    settings.replaceInvalidChars,
                    settings.maxFilenameLength
                );

                // Generate path for structured storage
                let path = '';
                if (!flatStructure) {
                    path = FilenameHelper.getFolderPath(artifact, 'Claude Conversation');
                }

                // Create file entry
                files.push({
                    filename,
                    content: artifact.content,
                    path,
                    artifact
                });
            }

            return files;
        } catch (error) {
            this.logger.error('ArtifactService: Error processing artifacts', error);
            throw error;
        }
    }

    /**
     * Store an artifact for potential stitching later
     */
    public async storeArtifact(artifact: Artifact): Promise<void> {
        try {
            // Generate a storage key based on title and type
            const key = `artifact-${artifact.title}-${artifact.type}`;

            // Store in local storage
            await this.storageService.saveArtifact(key, artifact);
        } catch (error) {
            this.logger.error('ArtifactService: Error storing artifact', error);
            throw error;
        }
    }

    /**
     * Retrieve stored artifacts
     */
    public async getStoredArtifacts(): Promise<Record<string, Artifact>> {
        try {
            // Implementation would depend on how artifacts are stored
            return {};
        } catch (error) {
            this.logger.error('ArtifactService: Error retrieving stored artifacts', error);
            throw error;
        }
    }
}


================================================================================
FILE: background/services/apiService.ts
================================================================================

import { LoggerService } from '../../shared/services/loggerService';
import { StorageService } from '../../shared/services/storageService';

/**
 * Service for interacting with external APIs
 */
export class ApiService {
    private static instance: ApiService;
    private readonly logger = LoggerService.getInstance();
    private readonly storageService = StorageService.getInstance();
    private apiKey: string = '';

    private constructor() {
        // Private constructor for singleton
    }

    /**
     * Get the singleton instance of the API service
     */
    public static getInstance(): ApiService {
        if (!ApiService.instance) {
            ApiService.instance = new ApiService();
        }
        return ApiService.instance;
    }

    /**
     * Initialize the API service
     */
    public async init(): Promise<void> {
        try {
            // Load settings
            const settings = await this.storageService.getSettings();
            this.apiKey = settings.apiSettings.apiKey;

            this.logger.debug('ApiService: Initialized');
        } catch (error) {
            this.logger.error('ApiService: Initialization error', error);
        }
    }

    /**
     * Send a prompt to Claude API
     */
    public async sendPrompt(prompt: string, options?: any): Promise<any> {
        try {
            // Load settings to get the latest API key
            const settings = await this.storageService.getSettings();
            const apiKey = settings.apiSettings.apiKey;

            if (!apiKey) {
                throw new Error('API key not configured');
            }

            // Prepare request options
            const requestOptions = {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-api-key': apiKey,
                    'anthropic-version': '2023-06-01'
                },
                body: JSON.stringify({
                    model: settings.apiSettings.modelName,
                    max_tokens: settings.apiSettings.maxTokens,
                    temperature: settings.apiSettings.temperature,
                    messages: [
                        {
                            role: 'user',
                            content: prompt
                        }
                    ]
                })
            };

            // Make API request
            const response = await fetch(settings.apiSettings.apiEndpoint, requestOptions);

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`API error (${response.status}): ${errorText}`);
            }

            const data = await response.json();
            return data;
        } catch (error) {
            this.logger.error('ApiService: Error sending prompt', error);
            throw error;
        }
    }

    /**
     * Compile code using remote service
     */
    public async compileCode(code: string, language: string): Promise<any> {
        try {
            // Load settings
            const settings = await this.storageService.getSettings();
            const apiKey = settings.compilerSettings.compilationApiKey;

            if (!settings.compilerSettings.enableCompilation) {
                throw new Error('Code compilation is disabled in settings');
            }

            if (!settings.compilerSettings.useRemoteCompilation) {
                throw new Error('Remote compilation is disabled in settings');
            }

            if (!settings.compilerSettings.supportedLanguages.includes(language)) {
                throw new Error(`Language not supported: ${language}`);
            }

            // Prepare request options
            const requestOptions = {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`
                },
                body: JSON.stringify({
                    language,
                    code,
                    timeout: settings.compilerSettings.executionTimeoutMs
                })
            };

            // Make API request
            const response = await fetch(settings.compilerSettings.remoteCompilationEndpoint, requestOptions);

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Compilation error (${response.status}): ${errorText}`);
            }

            const data = await response.json();
            return {
                output: data.output,
                error: data.error,
                executionTime: data.executionTime
            };
        } catch (error) {
            this.logger.error('ApiService: Error compiling code', error);

            // Return a simulated result for demonstration
            return {
                output: 'Remote compilation unavailable. This is a simulated response.',
                error: error instanceof Error ? error.message : 'Unknown error',
                executionTime: 0
            };
        }
    }
}


================================================================================
FILE: background/services/messageRouter.ts
================================================================================

import { LoggerService } from '../../shared/services/loggerService';
import { ArtifactService } from './artifactService';
import { DownloadService } from './downloadService';
import { ApiService } from './apiService';

/**
 * Router for handling messages from content scripts
 */
export class MessageRouter {
    private static instance: MessageRouter;
    private readonly logger = LoggerService.getInstance();
    private readonly artifactService = ArtifactService.getInstance();
    private readonly downloadService = DownloadService.getInstance();
    private readonly apiService = ApiService.getInstance();

    private constructor() {
        // Private constructor for singleton
    }

    /**
     * Get the singleton instance of the message router
     */
    public static getInstance(): MessageRouter {
        if (!MessageRouter.instance) {
            MessageRouter.instance = new MessageRouter();
        }
        return MessageRouter.instance;
    }

    /**
     * Initialize the message router
     */
    public init(): void {
        // Set up message listener
        chrome.runtime.onMessage.addListener(this.handleMessage.bind(this));

        this.logger.debug('MessageRouter: Initialized');
    }

    /**
     * Handle messages from content scripts
     */
    private handleMessage(
        message: any,
        sender: chrome.runtime.MessageSender,
        sendResponse: (response?: any) => void
    ): boolean {
        if (!message || !message.action) {
            sendResponse({ success: false, error: 'Invalid message format' });
            return false;
        }

        this.logger.debug('MessageRouter: Received message', message);

        // Process message based on action
        switch (message.action) {
            case 'downloadArtifacts':
                this.handleDownloadArtifacts(message, sendResponse);
                return true; // Keep connection open for async response

            case 'remoteCompile':
                this.handleRemoteCompile(message, sendResponse);
                return true; // Keep connection open for async response

            case 'apiRequest':
                this.handleApiRequest(message, sendResponse);
                return true; // Keep connection open for async response

            default:
                sendResponse({ success: false, error: `Unknown action: ${message.action}` });
                return false;
        }
    }

    /**
     * Handle artifact download request
     */
    private async handleDownloadArtifacts(message: any, sendResponse: (response?: any) => void): Promise<void> {
        try {
            const { artifacts, options } = message;

            if (!artifacts || !Array.isArray(artifacts)) {
                sendResponse({ success: false, error: 'No artifacts provided' });
                return;
            }

            // Process artifacts
            const files = await this.artifactService.processArtifacts(
                artifacts,
                options?.stitchArtifacts || false,
                options?.flatStructure || false
            );

            // Download as ZIP
            const filename = await this.downloadService.downloadArtifactsAsZip(files);

            sendResponse({
                success: true,
                filename,
                count: files.length
            });
        } catch (error) {
            this.logger.error('MessageRouter: Error handling download artifacts', error);
            sendResponse({
                success: false,
                error: error instanceof Error ? error.message : 'Unknown error'
            });
        }
    }

    /**
     * Handle remote code compilation request
     */
    private async handleRemoteCompile(message: any, sendResponse: (response?: any) => void): Promise<void> {
        try {
            const { code, language } = message;

            if (!code) {
                sendResponse({ success: false, error: 'No code provided' });
                return;
            }

            // Use API service to compile code
            const result = await this.apiService.compileCode(code, language);

            sendResponse({
                success: true,
                data: result
            });
        } catch (error) {
            this.logger.error('MessageRouter: Error handling remote compile', error);
            sendResponse({
                success: false,
                error: error instanceof Error ? error.message : 'Unknown error'
            });
        }
    }

    /**
     * Handle Claude API request
     */
    private async handleApiRequest(message: any, sendResponse: (response?: any) => void): Promise<void> {
        try {
            const { prompt, options } = message;

            if (!prompt) {
                sendResponse({ success: false, error: 'No prompt provided' });
                return;
            }

            // Use API service to make Claude API request
            const result = await this.apiService.sendPrompt(prompt, options);

            sendResponse({
                success: true,
                data: result
            });
        } catch (error) {
            this.logger.error('MessageRouter: Error handling API request', error);
            sendResponse({
                success: false,
                error: error instanceof Error ? error.message : 'Unknown error'
            });
        }
    }
}


================================================================================
FILE: options/index.ts
================================================================================



================================================================================
FILE: popup/index.ts
================================================================================



================================================================================
FILE: content/eventHandlers.js
================================================================================

import { sendMessageToBackground } from "./messaging.js";

export function downloadArtifacts() {
    const uuid = window.location.pathname.split("/").pop();
    const structure = document.querySelector(".claude-download-options").value;
    sendMessageToBackground({
        action: "downloadArtifacts",
        uuid,
        useDirectoryStructure: structure === "structured",
    });
}


================================================================================
FILE: content/messaging.js
================================================================================



================================================================================
FILE: content/banner.js
================================================================================

export function createBanner(message, type = "error", timeout = 8000) {
    const banner = document.createElement("article");
    banner.className = type;
    banner.innerHTML = `<p>${message}</p>`;
    document.body.prepend(banner);
    setTimeout(() => {
        banner.classList.add("hide");
        setTimeout(() => banner.remove(), 500);
    }, timeout);
}


================================================================================
FILE: content/index.ts
================================================================================

import { LoggerService } from '../shared/services/loggerService';
import { UiInjector } from './ui/UiInjector';
import { BannerService } from './ui/bannerService';
import { MessageService } from './events/messageService';
import { StorageService } from '../shared/services/storageService';
import { CompilerService } from './editor/compilerService';

/**
 * Main entry point for the content script
 */
class ContentScript {
    private readonly logger = LoggerService.getInstance();
    private readonly uiInjector = UiInjector.getInstance();
    private readonly bannerService = BannerService.getInstance();
    private readonly messageService = MessageService.getInstance();
    private readonly storageService = StorageService.getInstance();
    private readonly compilerService = CompilerService.getInstance();

    constructor() {
        this.init().catch(error => {
            console.error('ContentScript: Initialization error', error);
        });
    }

    /**
     * Initialize the content script
     */
    private async init(): Promise<void> {
        try {
            this.logger.info('ContentScript: Initializing');

            // Load settings
            const settings = await this.storageService.getSettings();

            // Set notification duration from settings
            this.bannerService.setNotificationDuration(
                settings.uiSettings.notificationDurationMs
            );

            // Register message handlers
            this.registerMessageHandlers();

            // Initialize UI injector
            await this.uiInjector.init();

            // Notification on successful initialization
            if (settings.uiSettings.showNotifications) {
                this.bannerService.showSuccess('Claude Artifacts extension initialized', 2000);
            }

            this.logger.info('ContentScript: Initialization complete');
        } catch (error) {
            this.logger.error('ContentScript: Initialization failed', error);
        }
    }

    /**
     * Register handlers for background script messages
     */
    private registerMessageHandlers(): void {
        // Handler for showing settings UI
        this.messageService.registerHandler('showSettings', async () => {
            // Implemented in settings UI module
            return true;
        });

        // Handler for showing notifications
        this.messageService.registerHandler('showNotification', async (message) => {
            const { type, text, duration } = message;

            switch (type) {
                case 'success':
                    this.bannerService.showSuccess(text, duration);
                    break;
                case 'error':
                    this.bannerService.showError(text, duration);
                    break;
                case 'info':
                    this.bannerService.showInfo(text, duration);
                    break;
                case 'warning':
                    this.bannerService.showWarning(text, duration);
                    break;
                default:
                    this.bannerService.showInfo(text, duration);
            }

            return true;
        });
    }
}

// Initialize content script
new ContentScript();


================================================================================
FILE: content/content.js
================================================================================

import "./uiInjector.js";
import "./eventHandlers.js";
import "./messaging.js";
import "./banner.js";

console.log("Claude Downloader Content Script Loaded.");


================================================================================
FILE: content/uiInjector.js
================================================================================

import { downloadArtifacts } from "./eventHandlers.js";

function injectUI() {
    const buttonContainer = document.querySelector(".flex.min-w-0.items-center.max-md\\:text-sm");
    if (!buttonContainer || buttonContainer.querySelector(".claude-download-button")) return;

    const container = document.createElement("div");
    container.className = "claude-download-container ml-1 flex items-center";
    container.innerHTML = `
    <select class="claude-download-options rounded-md bg-gray-100 py-1 px-2 text-sm">
      <option value="flat">Flat structure</option>
      <option value="structured">Inferred structure</option>
    </select>
    <button class="claude-download-button ml-1 rounded-md bg-gray-100 py-1 px-3 text-sm">
      <i class="fa fa-download mr-2"></i>Download artifacts
    </button>
  `;
    buttonContainer.appendChild(container);

    container.querySelector(".claude-download-button").onclick = downloadArtifacts;
}

setInterval(injectUI, 1500);


================================================================================
FILE: content/ui/settingsManager.ts
================================================================================

import { StorageService } from '@/background/storageService';
import {LoggerService} from '@/shared/services/loggerService';

export class SettingsManager {
    private static instance: SettingsManager;
    private readonly logger: LoggerService;
    private readonly storageService: StorageService;
    private settings: ISettings = {
        enabled: true
    };

    /**
     * Private constructor to enforce singleton pattern
     */
    private constructor() {
        this.logger = LoggerService.getInstance();
        this.storageService = StorageService.getInstance();
    }

    /**
     * Get the singleton instance
     */
    public static getInstance(): SettingsManager {
        if (!SettingsManager.instance) {
            SettingsManager.instance = new SettingsManager();
        }
        return SettingsManager.instance;
    }

    /**
     * Initialize the settings manager
     */
    public async initialize(): Promise<void> {
        await this.loadSettings();
        this.logger.info('SettingsManager initialized');
    }

    /**
     * Load settings from storage
     */
    private async loadSettings(): Promise<void> {
        this.settings = await this.storageService.get<ISettings>('settings') || this.settings;
    }

    /**
     * Save settings to storage
     */
    private async saveSettings(): Promise<void> {
        await this.storageService.set<ISettings>('settings', this.settings);

        // Notify listeners of the updated settings
        this.notifyListeners();
    }

    /**
     * Get the current settings
     */
    public getSettings(): ISettings {
        return this.settings;
    }

    /**
     * Update the settings
     * @param settings New settings
     */
    public async updateSettings(settings: ISettings): Promise<void> {
        this.settings = settings;
        await this.saveSettings();
    }

    // Listener functionality
    private listeners: Set<SettingsListener> = new Set();

    /**
     * Add a listener for settings changes
     * @param listener The listener to add
     */
    public addListener(listener: SettingsListener): void {
        this.listeners.add(listener);
    }

    /**
     * Remove a listener for settings changes
     * @param listener The listener to remove
     */
    public removeListener(listener: SettingsListener): void {
        this.listeners.delete(listener);
    }

    /**
     * Notify all listeners of settings changes
     */
    private notifyListeners(): void {
        this.listeners.forEach(listener => {
            try {
                listener(this.settings);
            } catch (error) {
                this.logger.error('Error in settings listener:', error);
            }
        });
    }

    /**
     * Clean up resources
     */
    public destroy(): void {
        this.listeners.clear();
        this.logger.info('SettingsManager destroyed');
    }
}


================================================================================
FILE: content/ui/uiInjector.ts
================================================================================

import { EditorManager } from '../editor/editorManager';
import { MessageService } from '../events/messageService';
import { BannerService } from './bannerService';
import { StorageService } from '../../shared/services/storageService';
import { LoggerService } from '../../shared/services/loggerService';
import { ArtifactSettings, UIElements } from '../../shared/models/settings';

/**
 * UiInjector is responsible for injecting UI elements into the Claude interface
 * and managing their lifecycle and event handling.
 */
export class UiInjector {
    private static instance: UiInjector;
    private readonly logger = LoggerService.getInstance();
    private readonly messageService = MessageService.getInstance();
    private readonly bannerService = BannerService.getInstance();
    private readonly storageService = StorageService.getInstance();
    private readonly editorManager = EditorManager.getInstance();

    private observer: MutationObserver | null = null;
    private downloadButton: HTMLButtonElement | null = null;
    private settingsButton: HTMLButtonElement | null = null;
    private headerContainer: HTMLElement | null = null;
    private isInitialized = false;
    private settings: ArtifactSettings | null = null;

    // UI Element selectors
    private readonly SELECTORS = {
        CLAUDE_HEADER: '.claude-header',
        CLAUDE_CONTROLS: '.claude-controls',
        ARTIFACT_CONTAINER: '.antml-artifact-container',
        ARTIFACT_TITLE: '.antml-artifact-title',
        MESSAGE_CONTAINER: '.prose',
        CONVERSATION_CONTAINER: '.conversation-container'
    };

    private constructor() {
        this.logger.debug('UiInjector: Initializing');
    }

    public static getInstance(): UiInjector {
        if (!UiInjector.instance) {
            UiInjector.instance = new UiInjector();
        }
        return UiInjector.instance;
    }

    /**
     * Initialize the UI injector by loading settings and starting the observer
     */
    public async init(): Promise<void> {
        if (this.isInitialized) {
            return;
        }

        try {
            this.settings = await this.storageService.getSettings();
            this.startObserver();
            this.injectStylesheet();
            this.isInitialized = true;
            this.logger.info('UiInjector: Initialized successfully');
        } catch (error) {
            this.logger.error('UiInjector: Failed to initialize', error);
            this.bannerService.showError('Failed to initialize UI components');
        }
    }

    /**
     * Clean up resources when the injector is no longer needed
     */
    public destroy(): void {
        if (this.observer) {
            this.observer.disconnect();
            this.observer = null;
        }
        this.removeInjectedElements();
        this.isInitialized = false;
        this.logger.debug('UiInjector: Destroyed');
    }

    /**
     * Start a mutation observer to watch for changes in the DOM
     * that would indicate we need to inject our UI elements
     */
    private startObserver(): void {
        if (this.observer) {
            this.observer.disconnect();
        }

        this.observer = new MutationObserver(this.handleDomMutations.bind(this));
        this.observer.observe(document.body, {
            childList: true,
            subtree: true
        });

        // Also check immediately in case the elements are already present
        this.checkAndInjectElements();
    }

    /**
     * Handle DOM mutations by checking if we need to inject elements
     */
    private handleDomMutations(mutations: MutationRecord[]): void {
        // Only process if we have new nodes added
        const hasNewNodes = mutations.some(mutation =>
            mutation.type === 'childList' && mutation.addedNodes.length > 0);

        if (hasNewNodes) {
            this.checkAndInjectElements();
        }
    }

    /**
     * Check if relevant Claude elements exist and inject our custom elements if needed
     */
    private checkAndInjectElements(): void {
        // Try to find the Claude header if we don't already have it
        if (!this.headerContainer) {
            this.headerContainer = document.querySelector(this.SELECTORS.CLAUDE_HEADER);
        }

        // If we found the header, inject our buttons
        if (this.headerContainer && !this.downloadButton) {
            this.injectButtons();
        }

        // Process any artifacts that might be on the page
        this.processExistingArtifacts();
    }

    /**
     * Inject the download and settings buttons into the Claude header
     */
    private injectButtons(): void {
        const controlsContainer = this.headerContainer?.querySelector(this.SELECTORS.CLAUDE_CONTROLS);

        if (!controlsContainer) {
            this.logger.warn('UiInjector: Could not find controls container');
            return;
        }

        // Create container for our buttons
        const buttonContainer = document.createElement('div');
        buttonContainer.className = 'claude-artifact-buttons';
        buttonContainer.style.display = 'flex';
        buttonContainer.style.gap = '8px';
        buttonContainer.style.marginLeft = '8px';

        // Create download button
        this.downloadButton = this.createDownloadButton();
        buttonContainer.appendChild(this.downloadButton);

        // Create settings button
        this.settingsButton = this.createSettingsButton();
        buttonContainer.appendChild(this.settingsButton);

        // Add buttons to the controls container
        controlsContainer.appendChild(buttonContainer);
        this.logger.info('UiInjector: Buttons injected');
    }

    /**
     * Create the download button with appropriate styling and event handling
     */
    private createDownloadButton(): HTMLButtonElement {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'claude-download-button';
        button.title = 'Download artifacts from this conversation';
        button.innerHTML = `
      <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
        <polyline points="7 10 12 15 17 10"></polyline>
        <line x1="12" y1="15" x2="12" y2="3"></line>
      </svg>
      <span>Download artifacts</span>
    `;

        // Add styling
        Object.assign(button.style, {
            display: 'flex',
            alignItems: 'center',
            gap: '6px',
            padding: '6px 12px',
            borderRadius: '4px',
            border: '1px solid #e2e8f0',
            backgroundColor: '#f8fafc',
            color: '#334155',
            cursor: 'pointer',
            fontSize: '14px',
            fontWeight: '500',
            transition: 'all 0.2s ease'
        });

        // Add event listener
        button.addEventListener('click', this.handleDownloadClick.bind(this));

        // Add hover effect
        button.addEventListener('mouseover', () => {
            Object.assign(button.style, {
                backgroundColor: '#f1f5f9',
                borderColor: '#cbd5e1'
            });
        });

        button.addEventListener('mouseout', () => {
            Object.assign(button.style, {
                backgroundColor: '#f8fafc',
                borderColor: '#e2e8f0'
            });
        });

        return button;
    }

    /**
     * Create the settings button with appropriate styling and event handling
     */
    private createSettingsButton(): HTMLButtonElement {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'claude-settings-button';
        button.title = 'Artifact download settings';
        button.innerHTML = `
      <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <circle cx="12" cy="12" r="3"></circle>
        <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
      </svg>
    `;

        // Add styling
        Object.assign(button.style, {
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            padding: '6px',
            borderRadius: '4px',
            border: '1px solid #e2e8f0',
            backgroundColor: '#f8fafc',
            color: '#334155',
            cursor: 'pointer',
            transition: 'all 0.2s ease'
        });

        // Add event listener
        button.addEventListener('click', this.handleSettingsClick.bind(this));

        // Add hover effect
        button.addEventListener('mouseover', () => {
            Object.assign(button.style, {
                backgroundColor: '#f1f5f9',
                borderColor: '#cbd5e1'
            });
        });

        button.addEventListener('mouseout', () => {
            Object.assign(button.style, {
                backgroundColor: '#f8fafc',
                borderColor: '#e2e8f0'
            });
        });

        return button;
    }

    /**
     * Process existing artifacts on the page to add edit buttons
     */
    private processExistingArtifacts(): void {
        const artifactContainers = document.querySelectorAll(this.SELECTORS.ARTIFACT_CONTAINER);

        artifactContainers.forEach(container => {
            // Skip already processed containers
            if (container.querySelector('.artifact-edit-button')) {
                return;
            }

            this.addArtifactControls(container as HTMLElement);
        });
    }

    /**
     * Add controls to an artifact container (edit, run buttons)
     */
    private addArtifactControls(container: HTMLElement): void {
        // Find the artifact title element to place our controls next to it
        const titleElement = container.querySelector(this.SELECTORS.ARTIFACT_TITLE);
        if (!titleElement) {
            return;
        }

        // Create controls container
        const controlsContainer = document.createElement('div');
        controlsContainer.className = 'artifact-controls';
        Object.assign(controlsContainer.style, {
            display: 'flex',
            gap: '8px',
            marginLeft: 'auto'
        });

        // Create edit button
        const editButton = this.createEditButton();
        controlsContainer.appendChild(editButton);

        // Create run button for code artifacts
        const isCodeArtifact = container.classList.contains('code-artifact') ||
            container.querySelector('pre code') !== null;

        if (isCodeArtifact) {
            const runButton = this.createRunButton();
            controlsContainer.appendChild(runButton);
        }

        // Add controls to the title element
        Object.assign(titleElement.style, {
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'space-between'
        });

        titleElement.appendChild(controlsContainer);

        // Store artifact data for later use
        this.storeArtifactData(container);
    }

    /**
     * Create an edit button for an artifact
     */
    private createEditButton(): HTMLButtonElement {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'artifact-edit-button';
        button.title = 'Edit this artifact';
        button.innerHTML = `
      <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
        <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
      </svg>
      <span>Edit</span>
    `;

        // Add styling
        Object.assign(button.style, {
            display: 'flex',
            alignItems: 'center',
            gap: '4px',
            padding: '4px 8px',
            borderRadius: '4px',
            border: '1px solid #e2e8f0',
            backgroundColor: '#f8fafc',
            color: '#334155',
            cursor: 'pointer',
            fontSize: '12px',
            fontWeight: '500'
        });

        // Add event listener
        button.addEventListener('click', (event) => {
            const artifactContainer = (event.target as HTMLElement)
                .closest(this.SELECTORS.ARTIFACT_CONTAINER) as HTMLElement;

            if (artifactContainer) {
                this.handleArtifactEdit(artifactContainer, button);
            }
        });

        return button;
    }

    /**
     * Create a run button for code artifacts
     */
    private createRunButton(): HTMLButtonElement {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'artifact-run-button';
        button.title = 'Run this code';
        button.innerHTML = `
      <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <polygon points="5 3 19 12 5 21 5 3"></polygon>
      </svg>
      <span>Run</span>
    `;

        // Add styling
        Object.assign(button.style, {
            display: 'flex',
            alignItems: 'center',
            gap: '4px',
            padding: '4px 8px',
            borderRadius: '4px',
            border: '1px solid #d1fae5',
            backgroundColor: '#ecfdf5',
            color: '#065f46',
            cursor: 'pointer',
            fontSize: '12px',
            fontWeight: '500'
        });

        // Add event listener
        button.addEventListener('click', (event) => {
            const artifactContainer = (event.target as HTMLElement)
                .closest(this.SELECTORS.ARTIFACT_CONTAINER) as HTMLElement;

            if (artifactContainer) {
                this.handleArtifactRun(artifactContainer);
            }
        });

        return button;
    }

    /**
     * Store artifact data for later reference
     */
    private storeArtifactData(container: HTMLElement): void {
        // Extract artifact metadata
        const titleElement = container.querySelector(this.SELECTORS.ARTIFACT_TITLE) as HTMLElement;
        const title = titleElement?.textContent?.trim() || 'Untitled Artifact';

        // Determine artifact type
        let artifactType = 'text';
        if (container.classList.contains('code-artifact') || container.querySelector('pre code')) {
            artifactType = 'code';
        } else if (container.querySelector('svg')) {
            artifactType = 'svg';
        } else if (container.querySelector('table')) {
            artifactType = 'table';
        }

        // Get language for code artifacts
        let language = '';
        const codeElement = container.querySelector('pre code');
        if (codeElement) {
            const classNames = Array.from(codeElement.classList);
            const langClass = classNames.find(cls => cls.startsWith('language-'));
            if (langClass) {
                language = langClass.replace('language-', '');
            }
        }

        // Store the data as a data attribute on the container
        container.dataset.artifactMetadata = JSON.stringify({
            title,
            type: artifactType,
            language,
            timestamp: new Date().toISOString()
        });
    }

    /**
     * Handle the download button click
     */
    private async handleDownloadClick(): Promise<void> {
        try {
            this.downloadButton?.setAttribute('disabled', 'true');
            this.downloadButton?.classList.add('loading');

            // Update button text
            const originalText = this.downloadButton?.innerHTML || '';
            this.downloadButton!.innerHTML = `
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="animate-spin">
          <circle cx="12" cy="12" r="10"></circle>
          <path d="M16 12a4 4 0 1 1-8 0 4 4 0 0 1 8 0z"></path>
        </svg>
        <span>Processing...</span>
      `;

            // Request artifact download from background script
            const result = await this.messageService.sendMessage({
                action: 'downloadArtifacts',
                options: {
                    stitchArtifacts: this.settings?.stitchArtifacts || false,
                    flatStructure: this.settings?.flatFileStructure || false
                }
            });

            if (result.success) {
                this.bannerService.showSuccess('Artifacts downloaded successfully');
            } else {
                this.bannerService.showError(result.error || 'Failed to download artifacts');
            }
        } catch (error) {
            this.logger.error('UiInjector: Download error', error);
            this.bannerService.showError('Failed to download artifacts');
        } finally {
            // Restore button state
            if (this.downloadButton) {
                this.downloadButton.removeAttribute('disabled');
                this.downloadButton.classList.remove('loading');
                this.downloadButton.innerHTML = originalText || `
          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
            <polyline points="7 10 12 15 17 10"></polyline>
            <line x1="12" y1="15" x2="12" y2="3"></line>
          </svg>
          <span>Download artifacts</span>
        `;
            }
        }
    }

    /**
     * Handle settings button click
     */
    private handleSettingsClick(): void {
        // Send message to show settings
        this.messageService.sendMessage({
            action: 'showSettings'
        });
    }

    /**
     * Handle artifact edit button click
     */
    private async handleArtifactEdit(container: HTMLElement, button: HTMLButtonElement): Promise<void> {
        try {
            const isEditMode = container.classList.contains('editing-mode');

            if (isEditMode) {
                // Save changes and exit edit mode
                await this.editorManager.saveChanges(container);
                button.innerHTML = `
          <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
            <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
          </svg>
          <span>Edit</span>
        `;
            } else {
                // Enter edit mode
                await this.editorManager.createEditor(container);
                button.innerHTML = `
          <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
            <polyline points="17 21 17 13 7 13 7 21"></polyline>
            <polyline points="7 3 7 8 15 8"></polyline>
          </svg>
          <span>Save</span>
        `;
            }
        } catch (error) {
            this.logger.error('UiInjector: Edit error', error);
            this.bannerService.showError('Failed to edit artifact');
        }
    }

    /**
     * Handle artifact run button click
     */
    private async handleArtifactRun(container: HTMLElement): Promise<void> {
        try {
            const metadata = this.extractArtifactMetadata(container);

            if (!metadata || metadata.type !== 'code') {
                this.bannerService.showError('Can only run code artifacts');
                return;
            }

            // Get the code content
            let code: string;

            if (container.classList.contains('editing-mode')) {
                // Get code from Monaco editor
                code = this.editorManager.getEditorContent(container) || '';
            } else {
                // Get code from pre element
                const codeElement = container.querySelector('pre code');
                code = codeElement?.textContent || '';
            }

            if (!code.trim()) {
                this.bannerService.showError('No code to run');
                return;
            }

            // Show compiling message
            this.bannerService.showInfo('Compiling code...');

            // Send code to compiler service
            const result = await this.messageService.sendMessage({
                action: 'compileAndRun',
                code,
                language: metadata.language || 'javascript'
            });

            if (result.success) {
                // Create or update output container
                this.displayCompilationResult(container, result.data);
            } else {
                this.bannerService.showError(result.error || 'Failed to run code');
            }
        } catch (error) {
            this.logger.error('UiInjector: Run error', error);
            this.bannerService.showError('Failed to run code');
        }
    }

    /**
     * Display compilation results
     */
    private displayCompilationResult(container: HTMLElement, result: any): void {
        // Check if output container already exists
        let outputContainer = container.querySelector('.compilation-output');

        if (!outputContainer) {
            // Create new output container
            outputContainer = document.createElement('div');
            outputContainer.className = 'compilation-output';
            Object.assign(outputContainer.style, {
                marginTop: '12px',
                padding: '12px',
                backgroundColor: '#f8fafc',
                borderRadius: '4px',
                border: '1px solid #e2e8f0',
                maxHeight: '300px',
                overflow: 'auto',
                fontSize: '14px',
                fontFamily: 'monospace'
            });

            container.appendChild(outputContainer);
        }

        // Clear previous content
        outputContainer.innerHTML = '';

        // Add header
        const header = document.createElement('div');
        header.style.fontWeight = 'bold';
        header.style.marginBottom = '8px';
        header.style.display = 'flex';
        header.style.justifyContent = 'space-between';
        header.innerHTML = `
      <span>Execution Results</span>
      <span class="close-output" style="cursor:pointer"></span>
    `;
        outputContainer.appendChild(header);

        // Add close button handler
        header.querySelector('.close-output')?.addEventListener('click', () => {
            outputContainer?.remove();
        });

        // Add content based on result type
        if (result.error) {
            const errorDiv = document.createElement('div');
            errorDiv.style.color = '#ef4444';
            errorDiv.textContent = result.error;
            outputContainer.appendChild(errorDiv);
        } else {
            // Create content based on result type
            if (typeof result.output === 'string') {
                const outputPre = document.createElement('pre');
                outputPre.style.margin = '0';
                outputPre.style.whiteSpace = 'pre-wrap';
                outputPre.textContent = result.output;
                outputContainer.appendChild(outputPre);
            } else {
                try {
                    const outputPre = document.createElement('pre');
                    outputPre.style.margin = '0';
                    outputPre.style.whiteSpace = 'pre-wrap';
                    outputPre.textContent = JSON.stringify(result.output, null, 2);
                    outputContainer.appendChild(outputPre);
                } catch (e) {
                    const outputDiv = document.createElement('div');
                    outputDiv.textContent = 'Complex output (cannot display)';
                    outputContainer.appendChild(outputDiv);
                }
            }
        }
    }

    /**
     * Extract artifact metadata from data attribute
     */
    private extractArtifactMetadata(container: HTMLElement): any {
        try {
            const metadataStr = container.dataset.artifactMetadata;
            if (metadataStr) {
                return JSON.parse(metadataStr);
            }
        } catch (error) {
            this.logger.error('UiInjector: Failed to parse artifact metadata', error);
        }
        return null;
    }

    /**
     * Inject the stylesheet for custom UI elements
     */
    private injectStylesheet(): void {
        const style = document.createElement('style');
        style.id = 'claude-artifacts-styles';
        style.textContent = `
      .claude-artifact-buttons button:focus-visible {
        outline: 2px solid #3b82f6;
        outline-offset: 2px;
      }
      
      .artifact-controls button:focus-visible {
        outline: 2px solid #3b82f6;
        outline-offset: 2px;
      }
      
      .editing-mode {
        position: relative;
      }
      
      .monaco-editor {
        min-height: 100px;
        border-radius: 4px;
        overflow: hidden;
      }
      
      .compilation-output::-webkit-scrollbar {
        width: 8px;
        height: 8px;
      }
      
      .compilation-output::-webkit-scrollbar-track {
        background: #f1f5f9;
      }
      
      .compilation-output::-webkit-scrollbar-thumb {
        background-color: #cbd5e1;
        border-radius: 4px;
      }
      
      @keyframes fadeIn {
        from { opacity: 0; transform: translateY(-10px); }
        to { opacity: 1; transform: translateY(0); }
      }
      
      .artifact-notification {
        animation: fadeIn 0.3s ease-out forwards;
      }
    `;

        document.head.appendChild(style);
    }

    /**
     * Remove injected UI elements
     */
    private removeInjectedElements(): void {
        // Remove buttons
        document.querySelector('.claude-artifact-buttons')?.remove();

        // Remove styles
        document.getElementById('claude-artifacts-styles')?.remove();

        // Restore artifact containers
        document.querySelectorAll('.editing-mode').forEach(editor => {
            this.editorManager.removeEditor(editor as HTMLElement);
        });

        // Remove compilation outputs
        document.querySelectorAll('.compilation-output').forEach(output => {
            output.remove();
        });

        // Reset state
        this.downloadButton = null;
        this.settingsButton = null;
        this.headerContainer = null;
    }
}


================================================================================
FILE: content/ui/settingsUI.ts
================================================================================

import { LoggerService } from '../../shared/services/loggerService';
import { StorageService } from '../../shared/services/storageService';
import { MessageService } from '../events/messageService';
import { BannerService } from './bannerService';
import { ArtifactSettings, DEFAULT_SETTINGS } from '../../shared/models/settings';

/**
 * UI for managing extension settings
 */
export class SettingsUI {
    private static instance: SettingsUI;
    private readonly logger = LoggerService.getInstance();
    private readonly storageService = StorageService.getInstance();
    private readonly messageService = MessageService.getInstance();
    private readonly bannerService = BannerService.getInstance();

    private settingsPanel: HTMLElement | null = null;
    private isVisible = false;
    private settings: ArtifactSettings | null = null;

    private constructor() {
        // Register message handler for showing settings
        this.messageService.registerHandler('showSettings', this.handleShowSettings.bind(this));
    }

    /**
     * Get the singleton instance of the settings UI
     */
    public static getInstance(): SettingsUI {
        if (!SettingsUI.instance) {
            SettingsUI.instance = new SettingsUI();
        }
        return SettingsUI.instance;
    }

    /**
     * Show the settings panel
     */
    public async show(): Promise<void> {
        if (this.isVisible) return;

        try {
            // Load settings
            this.settings = await this.storageService.getSettings();

            // Create panel if it doesn't exist
            if (!this.settingsPanel) {
                this.createSettingsPanel();
            }

            // Show the panel
            if (this.settingsPanel) {
                document.body.appendChild(this.settingsPanel);

                // Add animation
                setTimeout(() => {
                    if (this.settingsPanel) {
                        this.settingsPanel.style.opacity = '1';
                        this.settingsPanel.style.transform = 'translateY(0)';
                    }
                }, 10);

                this.isVisible = true;
            }
        } catch (error) {
            this.logger.error('SettingsUI: Error showing settings', error);
            this.bannerService.showError('Failed to load settings');
        }
    }

    /**
     * Hide the settings panel
     */
    public hide(): void {
        if (!this.isVisible || !this.settingsPanel) return;

        // Add animation
        this.settingsPanel.style.opacity = '0';
        this.settingsPanel.style.transform = 'translateY(20px)';

        // Remove after animation
        setTimeout(() => {
            if (this.settingsPanel && this.settingsPanel.parentNode) {
                this.settingsPanel.parentNode.removeChild(this.settingsPanel);
            }
            this.isVisible = false;
        }, 300);
    }

    /**
     * Create the settings panel UI
     */
    private createSettingsPanel(): void {
        // Create panel container
        const panel = document.createElement('div');
        panel.className = 'claude-artifacts-settings';
        panel.setAttribute('role', 'dialog');
        panel.setAttribute('aria-labelledby', 'settings-title');

        // Base styling
        Object.assign(panel.style, {
            position: 'fixed',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%) translateY(20px)',
            maxWidth: '600px',
            width: '90%',
            maxHeight: '80vh',
            backgroundColor: '#ffffff',
            borderRadius: '8px',
            boxShadow: '0 4px 20px rgba(0, 0, 0, 0.15)',
            zIndex: '10000',
            overflow: 'hidden',
            display: 'flex',
            flexDirection: 'column',
            opacity: '0',
            transition: 'opacity 0.3s ease, transform 0.3s ease'
        });

        // Add content
        panel.innerHTML = `
      <div style="display: flex; align-items: center; justify-content: space-between; padding: 16px 20px; border-bottom: 1px solid #e2e8f0;">
        <h2 id="settings-title" style="margin: 0; font-size: 18px; font-weight: 600; color: #1e293b;">Claude Artifacts Settings</h2>
        <button id="close-settings" style="background: none; border: none; cursor: pointer; padding: 4px;">
          <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
          </svg>
        </button>
      </div>
      
      <div style="flex: 1; overflow-y: auto; padding: 20px;">
        <div style="display: flex; flex-direction: column; gap: 24px;">
          <!-- Artifact Download Settings -->
          <section>
            <h3 style="margin: 0 0 12px 0; font-size: 16px; font-weight: 600; color: #334155;">Artifact Download</h3>
            <div style="display: flex; flex-direction: column; gap: 12px;">
              <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                <input type="checkbox" id="stitch-artifacts" ${this.settings?.stitchArtifacts ? 'checked' : ''}>
                <span>Automatically stitch related artifacts</span>
              </label>
              
              <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                <input type="checkbox" id="flat-structure" ${this.settings?.flatFileStructure ? 'checked' : ''}>
                <span>Use flat file structure (no folders)</span>
              </label>
              
              <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                <input type="checkbox" id="include-timestamp" ${this.settings?.includeTimestampInFilename ? 'checked' : ''}>
                <span>Include timestamp in filenames</span>
              </label>
            </div>
          </section>
          
          <!-- Editor Settings -->
          <section>
            <h3 style="margin: 0 0 12px 0; font-size: 16px; font-weight: 600; color: #334155;">Editor</h3>
            <div style="display: flex; flex-direction: column; gap: 12px;">
              <div>
                <label for="editor-theme" style="display: block; margin-bottom: 4px;">Theme</label>
                <select id="editor-theme" style="width: 100%; padding: 8px; border: 1px solid #e2e8f0; border-radius: 4px;">
                  <option value="vs" ${this.settings?.editorSettings.theme === 'vs' ? 'selected' : ''}>Light</option>
                  <option value="vs-dark" ${this.settings?.editorSettings.theme === 'vs-dark' ? 'selected' : ''}>Dark</option>
                  <option value="hc-black" ${this.settings?.editorSettings.theme === 'hc-black' ? 'selected' : ''}>High Contrast</option>
                </select>
              </div>
              
              <div>
                <label for="font-size" style="display: block; margin-bottom: 4px;">Font Size</label>
                <input type="number" id="font-size" min="10" max="24" value="${this.settings?.editorSettings.fontSize || 14}" style="width: 100%; padding: 8px; border: 1px solid #e2e8f0; border-radius: 4px;">
              </div>
              
              <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                <input type="checkbox" id="line-numbers" ${this.settings?.editorSettings.lineNumbers === 'on' ? 'checked' : ''}>
                <span>Show line numbers</span>
              </label>
              
              <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                <input type="checkbox" id="word-wrap" ${this.settings?.editorSettings.wordWrap === 'on' ? 'checked' : ''}>
                <span>Word wrap</span>
              </label>
              
              <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                <input type="checkbox" id="minimap" ${this.settings?.editorSettings.minimap ? 'checked' : ''}>
                <span>Show minimap</span>
              </label>
            </div>
          </section>
          
          <!-- API Settings -->
          <section>
            <h3 style="margin: 0 0 12px 0; font-size: 16px; font-weight: 600; color: #334155;">API Settings</h3>
            <div style="display: flex; flex-direction: column; gap: 12px;">
              <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                <input type="checkbox" id="enable-api" ${this.settings?.apiSettings.enableApiContinuation ? 'checked' : ''}>
                <span>Enable API continuation when rate limited</span>
              </label>
              
              <div>
                <label for="api-key" style="display: block; margin-bottom: 4px;">Claude API Key</label>
                <input type="password" id="api-key" value="${this.settings?.apiSettings.apiKey || ''}" placeholder="sk-..." style="width: 100%; padding: 8px; border: 1px solid #e2e8f0; border-radius: 4px;">
              </div>
              
              <div>
                <label for="model-name" style="display: block; margin-bottom: 4px;">Model</label>
                <select id="model-name" style="width: 100%; padding: 8px; border: 1px solid #e2e8f0; border-radius: 4px;">
                  <option value="claude-3-haiku-20240307" ${this.settings?.apiSettings.modelName === 'claude-3-haiku-20240307' ? 'selected' : ''}>Claude 3 Haiku</option>
                  <option value="claude-3-sonnet-20240229" ${this.settings?.apiSettings.modelName === 'claude-3-sonnet-20240229' ? 'selected' : ''}>Claude 3 Sonnet</option>
                  <option value="claude-3-opus-20240229" ${this.settings?.apiSettings.modelName === 'claude-3-opus-20240229' ? 'selected' : ''}>Claude 3 Opus</option>
                </select>
              </div>
            </div>
          </section>
          
          <!-- Reset Settings -->
          <section>
            <button id="reset-settings" style="padding: 8px 16px; background-color: #f1f5f9; border: 1px solid #cbd5e1; border-radius: 4px; cursor: pointer; color: #334155; font-weight: 500;">
              Reset to Defaults
            </button>
          </section>
        </div>
      </div>
      
      <div style="padding: 16px 20px; border-top: 1px solid #e2e8f0; display: flex; justify-content: flex-end; gap: 12px;">
        <button id="cancel-settings" style="padding: 8px 16px; background-color: #f1f5f9; border: 1px solid #cbd5e1; border-radius: 4px; cursor: pointer; color: #334155; font-weight: 500;">
          Cancel
        </button>
        <button id="save-settings" style="padding: 8px 16px; background-color: #2563eb; border: none; border-radius: 4px; cursor: pointer; color: white; font-weight: 500;">
          Save Changes
        </button>
      </div>
    `;

        // Add backdrop
        const backdrop = document.createElement('div');
        backdrop.style.position = 'fixed';
        backdrop.style.top = '0';
        backdrop.style.left = '0';
        backdrop.style.width = '100%';
        backdrop.style.height = '100%';
        backdrop.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
        backdrop.style.zIndex = '9999';
        backdrop.style.opacity = '0';
        backdrop.style.transition = 'opacity 0.3s ease';

        // Add handlers
        setTimeout(() => {
            backdrop.style.opacity = '1';
        }, 10);

        backdrop.addEventListener('click', () => {
            this.hide();
        });

        // Add event listeners
        panel.querySelector('#close-settings')?.addEventListener('click', () => {
            this.hide();
        });

        panel.querySelector('#cancel-settings')?.addEventListener('click', () => {
            this.hide();
        });

        panel.querySelector('#save-settings')?.addEventListener('click', () => {
            this.saveSettings();
        });

        panel.querySelector('#reset-settings')?.addEventListener('click', () => {
            this.resetSettings();
        });

        // Prevent clicks inside panel from closing
        panel.addEventListener('click', (e) => {
            e.stopPropagation();
        });

        // Store references
        this.settingsPanel = panel;

        // Add panel and backdrop to the DOM
        document.body.appendChild(backdrop);
    }

    /**
     * Save settings changes
     */
    private async saveSettings(): Promise<void> {
        if (!this.settings) return;

        try {
            // Get values from form elements
            const stitchArtifacts = (document.getElementById('stitch-artifacts') as HTMLInputElement)?.checked ?? this.settings.stitchArtifacts;
            const flatStructure = (document.getElementById('flat-structure') as HTMLInputElement)?.checked ?? this.settings.flatFileStructure;
            const includeTimestamp = (document.getElementById('include-timestamp') as HTMLInputElement)?.checked ?? this.settings.includeTimestampInFilename;

            // Editor settings
            const editorTheme = (document.getElementById('editor-theme') as HTMLSelectElement)?.value as 'vs' | 'vs-dark' | 'hc-black';
            const fontSize = parseInt((document.getElementById('font-size') as HTMLInputElement)?.value || '14');
            const lineNumbers = (document.getElementById('line-numbers') as HTMLInputElement)?.checked ? 'on' : 'off';
            const wordWrap = (document.getElementById('word-wrap') as HTMLInputElement)?.checked ? 'on' : 'off';
            const minimap = (document.getElementById('minimap') as HTMLInputElement)?.checked ?? this.settings.editorSettings.minimap;

            // API settings
            const enableApi = (document.getElementById('enable-api') as HTMLInputElement)?.checked ?? this.settings.apiSettings.enableApiContinuation;
            const apiKey = (document.getElementById('api-key') as HTMLInputElement)?.value || '';
            const modelName = (document.getElementById('model-name') as HTMLSelectElement)?.value || this.settings.apiSettings.modelName;

            // Update settings
            const updatedSettings: ArtifactSettings = {
                ...this.settings,
                stitchArtifacts,
                flatFileStructure: flatStructure,
                includeTimestampInFilename: includeTimestamp,
                editorSettings: {
                    ...this.settings.editorSettings,
                    theme: editorTheme,
                    fontSize,
                    lineNumbers: lineNumbers as 'on' | 'off' | 'relative',
                    wordWrap: wordWrap as 'on' | 'off',
                    minimap
                },
                apiSettings: {
                    ...this.settings.apiSettings,
                    enableApiContinuation: enableApi,
                    apiKey,
                    modelName
                }
            };

            // Save settings
            await this.storageService.saveSettings(updatedSettings);

            // Show success message
            this.bannerService.showSuccess('Settings saved successfully');

            // Hide panel
            this.hide();
        } catch (error) {
            this.logger.error('SettingsUI: Error saving settings', error);
            this.bannerService.showError('Failed to save settings');
        }
    }

    /**
     * Reset settings to defaults
     */
    private async resetSettings(): Promise<void> {
        try {
            // Confirm reset
            if (!confirm('Reset all settings to defaults?')) {
                return;
            }

            // Save default settings
            await this.storageService.saveSettings(DEFAULT_SETTINGS);

            // Update reference
            this.settings = DEFAULT_SETTINGS;

            // Show success message
            this.bannerService.showSuccess('Settings reset to defaults');

            // Hide and recreate panel to show updated values
            if (this.settingsPanel && this.settingsPanel.parentNode) {
                this.settingsPanel.parentNode.removeChild(this.settingsPanel);
            }
            this.settingsPanel = null;
            this.isVisible = false;

            // Show settings again
            this.show();
        } catch (error) {
            this.logger.error('SettingsUI: Error resetting settings', error);
            this.bannerService.showError('Failed to reset settings');
        }
    }

    /**
     * Handle showSettings message
     */
    private async handleShowSettings(): Promise<boolean> {
        await this.show();
        return true;
    }
}


================================================================================
FILE: content/ui/bannerService.ts
================================================================================

import { LoggerService } from '../../shared/services/loggerService';

/**
 * Service for showing notification banners in the UI
 */
export class BannerService {
    private static instance: BannerService;
    private readonly logger = LoggerService.getInstance();
    private activeNotifications: Set<HTMLElement> = new Set();
    private notificationContainer: HTMLElement | null = null;
    private notificationDuration = 3000; // ms

    private constructor() {
        // Private constructor for singleton
    }

    /**
     * Get the singleton instance of the banner service
     */
    public static getInstance(): BannerService {
        if (!BannerService.instance) {
            BannerService.instance = new BannerService();
        }
        return BannerService.instance;
    }

    /**
     * Set the duration for notifications
     */
    public setNotificationDuration(durationMs: number): void {
        this.notificationDuration = durationMs;
    }

    /**
     * Show a success notification banner
     */
    public showSuccess(message: string, duration?: number): void {
        this.showNotification(message, 'success', duration);
    }

    /**
     * Show an error notification banner
     */
    public showError(message: string, duration?: number): void {
        this.showNotification(message, 'error', duration);
    }

    /**
     * Show an info notification banner
     */
    public showInfo(message: string, duration?: number): void {
        this.showNotification(message, 'info', duration);
    }

    /**
     * Show a warning notification banner
     */
    public showWarning(message: string, duration?: number): void {
        this.showNotification(message, 'warning', duration);
    }

    /**
     * Show a notification banner with custom styling
     */
    private showNotification(message: string, type: 'success' | 'error' | 'info' | 'warning', duration?: number): void {
        this.ensureContainer();

        const notification = this.createNotificationElement(message, type);
        this.notificationContainer!.appendChild(notification);
        this.activeNotifications.add(notification);

        // Add to DOM and trigger animation
        setTimeout(() => {
            notification.style.opacity = '1';
            notification.style.transform = 'translateY(0)';
        }, 10);

        // Set up auto-remove after duration
        const timeoutDuration = duration ?? this.notificationDuration;
        const timeout = setTimeout(() => {
            this.removeNotification(notification);
        }, timeoutDuration);

        // Store timeout ID for potential early removal
        (notification as any)._removeTimeout = timeout;

        // Add click handler to remove on click
        notification.addEventListener('click', () => {
            clearTimeout((notification as any)._removeTimeout);
            this.removeNotification(notification);
        });
    }

    /**
     * Remove a notification with animation
     */
    private removeNotification(notification: HTMLElement): void {
        // Don't remove if already removing
        if (notification.classList.contains('removing')) {
            return;
        }

        notification.classList.add('removing');
        notification.style.opacity = '0';
        notification.style.transform = 'translateY(-10px)';

        // Remove from DOM after animation
        setTimeout(() => {
            if (notification.parentNode) {
                notification.parentNode.removeChild(notification);
            }
            this.activeNotifications.delete(notification);

            // Clean up container if no more notifications
            if (this.activeNotifications.size === 0 && this.notificationContainer) {
                this.notificationContainer.remove();
                this.notificationContainer = null;
            }
        }, 300);
    }

    /**
     * Create the notification element with appropriate styling
     */
    private createNotificationElement(message: string, type: 'success' | 'error' | 'info' | 'warning'): HTMLElement {
        const notification = document.createElement('div');
        notification.className = `artifact-notification artifact-notification-${type}`;
        notification.setAttribute('role', 'alert');

        // Base styles
        Object.assign(notification.style, {
            padding: '12px 16px',
            margin: '0 0 8px 0',
            borderRadius: '6px',
            boxShadow: '0 4px 6px rgba(0, 0, 0, 0.1)',
            fontFamily: 'system-ui, -apple-system, sans-serif',
            fontSize: '14px',
            lineHeight: '1.5',
            display: 'flex',
            alignItems: 'center',
            opacity: '0',
            transform: 'translateY(-10px)',
            transition: 'opacity 0.3s ease, transform 0.3s ease',
            cursor: 'pointer',
            maxWidth: '100%',
            overflow: 'hidden',
            textOverflow: 'ellipsis',
            position: 'relative'
        });

        // Type-specific styles
        const typeStyles = {
            success: {
                backgroundColor: '#ecfdf5',
                color: '#065f46',
                borderLeft: '4px solid #10b981'
            },
            error: {
                backgroundColor: '#fef2f2',
                color: '#991b1b',
                borderLeft: '4px solid #ef4444'
            },
            info: {
                backgroundColor: '#eff6ff',
                color: '#1e40af',
                borderLeft: '4px solid #3b82f6'
            },
            warning: {
                backgroundColor: '#fffbeb',
                color: '#92400e',
                borderLeft: '4px solid #f59e0b'
            }
        };

        Object.assign(notification.style, typeStyles[type]);

        // Create icon based on notification type
        const icon = document.createElement('span');
        icon.style.marginRight = '12px';

        const iconPaths: Record<string, string> = {
            success: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></svg>`,
            error: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line></svg>`,
            info: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg>`,
            warning: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>`
        };

        icon.innerHTML = iconPaths[type];
        notification.appendChild(icon);

        // Add message
        const messageSpan = document.createElement('span');
        messageSpan.textContent = message;
        notification.appendChild(messageSpan);

        return notification;
    }

    /**
     * Ensure the notification container exists in the DOM
     */
    private ensureContainer(): void {
        if (!this.notificationContainer) {
            this.notificationContainer = document.createElement('div');
            this.notificationContainer.className = 'artifact-notification-container';

            // Style the container
            Object.assign(this.notificationContainer.style, {
                position: 'fixed',
                top: '16px',
                right: '16px',
                zIndex: '10000',
                display: 'flex',
                flexDirection: 'column',
                alignItems: 'flex-end',
                maxWidth: '350px',
                pointerEvents: 'none' // Allow clicking through the container
            });

            // Make notifications themselves clickable
            const style = document.createElement('style');
            style.textContent = `
        .artifact-notification {
          pointer-events: auto;
        }
      `;
            this.notificationContainer.appendChild(style);

            document.body.appendChild(this.notificationContainer);
        }
    }

    /**
     * Remove all notifications immediately
     */
    public clearAll(): void {
        if (!this.notificationContainer) return;

        // Clear all timeouts
        this.activeNotifications.forEach(notification => {
            if ((notification as any)._removeTimeout) {
                clearTimeout((notification as any)._removeTimeout);
            }
        });

        // Remove container and reset state
        this.notificationContainer.remove();
        this.notificationContainer = null;
        this.activeNotifications.clear();
    }
}


================================================================================
FILE: content/styles/banner.css
================================================================================

article.error,
article.success {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    margin: 0;
    padding: 1rem;
    text-align: center;
    z-index: 9999;
    animation: slideDown 0.5s ease-out;
}

article.error {
    background-color: #d30c00;
    border-color: #d30c00;
    color: white;
}

article.success {
    background-color: #125019;
    border-color: #125019;
    color: white;
}

article.hide {
    animation: slideUp 0.5s ease-in forwards;
}

@keyframes slideDown {
    from { transform: translateY(-100%); }
    to { transform: translateY(0); }
}

@keyframes slideUp {
    from { transform: translateY(0); }
    to { transform: translateY(-100%); }
}


================================================================================
FILE: content/events/messageService.ts
================================================================================

import { LoggerService } from '../../shared/services/loggerService';

/**
 * Interface for all messages sent between content and background scripts
 */
export interface Message {
    action: string;
    [key: string]: any;
}

/**
 * Service for sending messages between content and background scripts
 */
export class MessageService {
    private static instance: MessageService;
    private readonly logger = LoggerService.getInstance();
    private messageHandlers: Map<string, (message: Message) => Promise<any>> = new Map();

    private constructor() {
        // Set up message listener
        chrome.runtime.onMessage.addListener(this.handleIncomingMessage.bind(this));
    }

    /**
     * Get the singleton instance of the message service
     */
    public static getInstance(): MessageService {
        if (!MessageService.instance) {
            MessageService.instance = new MessageService();
        }
        return MessageService.instance;
    }

    /**
     * Send a message to the background script
     */
    public async sendMessage(message: Message): Promise<any> {
        try {
            this.logger.debug('Sending message:', message);
            const response = await chrome.runtime.sendMessage(message);
            this.logger.debug('Received response:', response);
            return response;
        } catch (error) {
            this.logger.error('Error sending message:', error);
            throw error;
        }
    }

    /**
     * Register a handler for a specific message action
     */
    public registerHandler(action: string, handler: (message: Message) => Promise<any>): void {
        this.messageHandlers.set(action, handler);
        this.logger.debug(`Registered handler for action: ${action}`);
    }

    /**
     * Remove a handler for a specific message action
     */
    public removeHandler(action: string): void {
        this.messageHandlers.delete(action);
        this.logger.debug(`Removed handler for action: ${action}`);
    }

    /**
     * Handle incoming messages and route to appropriate handler
     */
    private handleIncomingMessage(message: Message, sender: chrome.runtime.MessageSender, sendResponse: (response?: any) => void): boolean {
        if (!message || !message.action) {
            this.logger.warn('Received invalid message:', message);
            sendResponse({ success: false, error: 'Invalid message format' });
            return false;
        }

        this.logger.debug('Received message:', message);

        const handler = this.messageHandlers.get(message.action);

        if (!handler) {
            this.logger.debug(`No handler registered for action: ${message.action}`);
            sendResponse({ success: false, error: `No handler for action: ${message.action}` });
            return false;
        }

        // Process with handler and send response
        handler(message)
            .then(result => {
                this.logger.debug('Handler result:', result);
                sendResponse({ success: true, data: result });
            })
            .catch(error => {
                this.logger.error(`Error handling message for action ${message.action}:`, error);
                sendResponse({
                    success: false,
                    error: error instanceof Error ? error.message : 'Unknown error'
                });
            });

        // Return true to indicate we'll use sendResponse asynchronously
        return true;
    }
}


================================================================================
FILE: content/events/rateLimitHandler.ts
================================================================================

import { LoggerService } from '../../shared/services/loggerService';
import { MessageService } from './messageService';
import { BannerService } from '../ui/bannerService';
import { StorageService } from '../../shared/services/storageService';

/**
 * Handler for Claude rate limit detection and API continuation
 */
export class RateLimitHandler {
    private static instance: RateLimitHandler;
    private readonly logger = LoggerService.getInstance();
    private readonly messageService = MessageService.getInstance();
    private readonly bannerService = BannerService.getInstance();
    private readonly storageService = StorageService.getInstance();

    private observer: MutationObserver | null = null;
    private isApiContinuationEnabled = false;
    private isRateLimited = false;
    private continueButton: HTMLButtonElement | null = null;

    private readonly RATE_LIMIT_SELECTORS = [
        '.rate-limit-message',
        '.rate-limited-container',
        '.message-error:contains("rate limit")'
    ];

    private constructor() {
        this.init().catch(error => {
            console.error('RateLimitHandler: Initialization error', error);
        });
    }

    /**
     * Get the singleton instance of the rate limit handler
     */
    public static getInstance(): RateLimitHandler {
        if (!RateLimitHandler.instance) {
            RateLimitHandler.instance = new RateLimitHandler();
        }
        return RateLimitHandler.instance;
    }

    /**
     * Initialize the rate limit handler
     */
    private async init(): Promise<void> {
        try {
            // Load settings
            const settings = await this.storageService.getSettings();
            this.isApiContinuationEnabled = settings.apiSettings.enableApiContinuation;

            // Start observing for rate limit messages
            this.startObserver();

            this.logger.debug('RateLimitHandler: Initialized');
        } catch (error) {
            this.logger.error('RateLimitHandler: Initialization failed', error);
        }
    }

    /**
     * Start observing for rate limit messages
     */
    private startObserver(): void {
        if (this.observer) {
            this.observer.disconnect();
        }

        this.observer = new MutationObserver(this.handleDomMutations.bind(this));
        this.observer.observe(document.body, {
            childList: true,
            subtree: true
        });

        // Also check immediately
        this.checkForRateLimit();
    }

    /**
     * Handle DOM mutations
     */
    private handleDomMutations(mutations: MutationRecord[]): void {
        // Only process if we have new nodes added
        const hasNewNodes = mutations.some(mutation =>
            mutation.type === 'childList' && mutation.addedNodes.length > 0);

        if (hasNewNodes) {
            this.checkForRateLimit();
        }
    }

    /**
     * Check for rate limit messages in the DOM
     */
    private checkForRateLimit(): void {
        // Skip if already handling rate limit or API continuation disabled
        if (this.isRateLimited || !this.isApiContinuationEnabled) {
            return;
        }

        // Check for rate limit messages
        for (const selector of this.RATE_LIMIT_SELECTORS) {
            const element = document.querySelector(selector);
            if (element) {
                this.handleRateLimit(element as HTMLElement);
                break;
            }
        }
    }

    /**
     * Handle rate limit detection
     */
    private async handleRateLimit(element: HTMLElement): Promise<void> {
        try {
            this.isRateLimited = true;
            this.logger.info('RateLimitHandler: Rate limit detected');

            // Check if API continuation is enabled and API key is set
            const settings = await this.storageService.getSettings();
            if (!settings.apiSettings.enableApiContinuation) {
                this.logger.debug('RateLimitHandler: API continuation disabled in settings');
                return;
            }

            if (!settings.apiSettings.apiKey) {
                this.bannerService.showWarning('API key not set. Please configure in settings to continue via API.');
                return;
            }

            // Add continue button
            this.addContinueButton(element);
        } catch (error) {
            this.logger.error('RateLimitHandler: Error handling rate limit', error);
        }
    }

    /**
     * Add a button to continue conversation via API
     */
    private addContinueButton(container: HTMLElement): void {
        // Check if button already exists
        if (this.continueButton || container.querySelector('.api-continue-button')) {
            return;
        }

        // Create button
        const button = document.createElement('button');
        button.className = 'api-continue-button';
        button.textContent = 'Continue with API';

        // Add styling
        Object.assign(button.style, {
            backgroundColor: '#2563eb',
            color: 'white',
            border: 'none',
            borderRadius: '4px',
            padding: '8px 16px',
            marginTop: '12px',
            cursor: 'pointer',
            fontWeight: '500',
            fontSize: '14px'
        });

        // Add event listener
        button.addEventListener('click', this.handleContinueClick.bind(this));

        // Add to container
        container.appendChild(button);
        this.continueButton = button;
    }

    /**
     * Handle continue button click
     */
    private async handleContinueClick(): Promise<void> {
        try {
            if (!this.continueButton) return;

            // Update button state
            this.continueButton.disabled = true;
            this.continueButton.textContent = 'Continuing...';

            // Extract current conversation context
            const conversationContext = this.extractConversationContext();

            // Send to background script for API continuation
            const response = await this.messageService.sendMessage({
                action: 'apiRequest',
                prompt: conversationContext.lastMessage,
                options: {
                    context: conversationContext.history
                }
            });

            if (response.success) {
                // Display API response
                this.displayApiResponse(response.data);

                // Clear rate limited state
                this.isRateLimited = false;

                // Show success message
                this.bannerService.showSuccess('Successfully continued with API');
            } else {
                throw new Error(response.error || 'Failed to continue with API');
            }
        } catch (error) {
            this.logger.error('RateLimitHandler: Error continuing with API', error);
            this.bannerService.showError('Failed to continue with API');

            // Reset button
            if (this.continueButton) {
                this.continueButton.disabled = false;
                this.continueButton.textContent = 'Continue with API';
            }
        }
    }

    /**
     * Extract conversation context
     */
    private extractConversationContext(): { history: string[], lastMessage: string } {
        // Implementation would extract conversation history from DOM
        const history: string[] = [];
        let lastMessage = '';

        // Find conversation container
        const conversationContainer = document.querySelector('.conversation-container');
        if (conversationContainer) {
            // Extract message elements
            const messageElements = conversationContainer.querySelectorAll('.message');

            messageElements.forEach(element => {
                const content = element.textContent || '';
                history.push(content);
            });

            // Extract last user message
            const lastUserMessage = conversationContainer.querySelector('.message.user:last-child');
            if (lastUserMessage) {
                lastMessage = lastUserMessage.textContent || '';
            }
        }

        return { history, lastMessage };
    }

    /**
     * Display API response in the UI
     */
    private displayApiResponse(apiResponse: any): void {
        // Implementation would display the API response in the UI
        // This could be complex and would interact with Claude's UI

        // For now, just show a message with the API result
        this.bannerService.showInfo('API response received. Displaying would require deep integration.');

        // Log the response
        this.logger.debug('RateLimitHandler: API response', apiResponse);
    }

    /**
     * Destroy the rate limit handler
     */
    public destroy(): void {
        if (this.observer) {
            this.observer.disconnect();
            this.observer = null;
        }

        if (this.continueButton && this.continueButton.parentNode) {
            this.continueButton.parentNode.removeChild(this.continueButton);
        }

        this.continueButton = null;
        this.isRateLimited = false;

        this.logger.debug('RateLimitHandler: Destroyed');
    }
}


================================================================================
FILE: content/editor/monacoEditorService.ts
================================================================================

import { LoggerService } from '../../shared/services/loggerService';

/**
 * Service for managing Monaco editor instances
 */
export class MonacoEditorService {
    private static instance: MonacoEditorService;
    private readonly logger = LoggerService.getInstance();
    private isMonacoLoaded = false;
    private loadPromise: Promise<void> | null = null;

    // CDN URL for Monaco editor
    private readonly MONACO_CDN_BASE = 'https://cdn.jsdelivr.net/npm/monaco-editor@0.40.0/min';

    // List of editors created by this service
    private editors: monaco.editor.IStandaloneCodeEditor[] = [];

    private constructor() {
        // Private constructor for singleton
    }

    /**
     * Get the singleton instance of the Monaco editor service
     */
    public static getInstance(): MonacoEditorService {
        if (!MonacoEditorService.instance) {
            MonacoEditorService.instance = new MonacoEditorService();
        }
        return MonacoEditorService.instance;
    }

    /**
     * Ensure Monaco editor is loaded
     */
    public ensureMonacoLoaded(): Promise<void> {
        if (this.isMonacoLoaded) {
            return Promise.resolve();
        }

        if (this.loadPromise) {
            return this.loadPromise;
        }

        this.loadPromise = this.loadMonaco();
        return this.loadPromise;
    }

    /**
     * Load Monaco editor from CDN
     */
    private async loadMonaco(): Promise<void> {
        this.logger.debug('MonacoEditorService: Loading Monaco editor from CDN');

        try {
            // Add Monaco loader script
            await this.loadScript(`${this.MONACO_CDN_BASE}/vs/loader.js`);

            // Configure AMD loader for Monaco
            (window as any).require.config({
                paths: {
                    vs: `${this.MONACO_CDN_BASE}/vs`
                }
            });

            // Load Monaco editor
            return new Promise<void>((resolve, reject) => {
                try {
                    (window as any).require(['vs/editor/editor.main'], () => {
                        this.isMonacoLoaded = true;
                        this.logger.info('MonacoEditorService: Monaco editor loaded successfully');
                        resolve();
                    });
                } catch (error) {
                    reject(error);
                }
            });
        } catch (error) {
            this.logger.error('MonacoEditorService: Failed to load Monaco editor', error);
            this.loadPromise = null;
            throw error;
        }
    }

    /**
     * Load a script from URL
     */
    private loadScript(url: string): Promise<void> {
        return new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = url;
            script.onload = () => resolve();
            script.onerror = (e) => reject(new Error(`Failed to load script: ${url}`));
            document.head.appendChild(script);
        });
    }

    /**
     * Create a Monaco editor instance
     */
    public createEditor(
        container: HTMLElement,
        options: monaco.editor.IStandaloneEditorConstructionOptions
    ): monaco.editor.IStandaloneCodeEditor {
        if (!this.isMonacoLoaded) {
            throw new Error('Monaco editor not loaded. Call ensureMonacoLoaded() first.');
        }

        const defaultOptions: monaco.editor.IStandaloneEditorConstructionOptions = {
            minimap: { enabled: true },
            lineNumbers: 'on',
            scrollBeyondLastLine: false,
            theme: 'vs',
            fontSize: 14,
            wordWrap: 'on',
            automaticLayout: true
        };

        const editorOptions = { ...defaultOptions, ...options };
        const editor = monaco.editor.create(container, editorOptions);

        // Store editor reference for cleanup
        this.editors.push(editor);

        return editor;
    }

    /**
     * Set theme for all editors
     */
    public setTheme(theme: 'vs' | 'vs-dark' | 'hc-black'): void {
        if (!this.isMonacoLoaded) return;

        monaco.editor.setTheme(theme);
        this.logger.debug(`MonacoEditorService: Set theme to ${theme}`);
    }

    /**
     * Dispose of a specific editor
     */
    public disposeEditor(editor: monaco.editor.IStandaloneCodeEditor): void {
        if (!editor) return;

        editor.dispose();
        this.editors = this.editors.filter(e => e !== editor);
        this.logger.debug('MonacoEditorService: Editor disposed');
    }

    /**
     * Dispose of all editors
     */
    public disposeAllEditors(): void {
        this.editors.forEach(editor => editor.dispose());
        this.editors = [];
        this.logger.info('MonacoEditorService: All editors disposed');
    }

    /**
     * Register a custom language for Monaco
     */
    public registerLanguage(languageId: string, configuration: any): void {
        if (!this.isMonacoLoaded) return;

        monaco.languages.register({ id: languageId });
        monaco.languages.setMonarchTokensProvider(languageId, configuration);
        this.logger.debug(`MonacoEditorService: Registered custom language ${languageId}`);
    }
}


================================================================================
FILE: content/editor/compilerService.ts
================================================================================

import { LoggerService } from '../../shared/services/loggerService';
import { MessageService } from '../events/messageService';

/**
 * Represents a compiler result
 */
interface CompilerResult {
    output: string | any;
    error?: string;
    executionTime?: number;
}

/**
 * Service for compiling and running code
 */
export class CompilerService {
    private static instance: CompilerService;
    private readonly logger = LoggerService.getInstance();
    private readonly messageService = MessageService.getInstance();

    private constructor() {
        // Register message handler for compiler requests
        this.messageService.registerHandler('compileAndRun', this.handleCompileAndRun.bind(this));
    }

    /**
     * Get the singleton instance of the compiler service
     */
    public static getInstance(): CompilerService {
        if (!CompilerService.instance) {
            CompilerService.instance = new CompilerService();
        }
        return CompilerService.instance;
    }

    /**
     * Handle compile and run message requests
     */
    private async handleCompileAndRun(message: any): Promise<CompilerResult> {
        const { code, language } = message;

        if (!code || !language) {
            return { output: '', error: 'Missing code or language' };
        }

        return this.compileAndRun(code, language);
    }

    /**
     * Compile and run code using the appropriate engine
     */
    public async compileAndRun(code: string, language: string): Promise<CompilerResult> {
        this.logger.debug(`CompilerService: Compiling ${language} code`);

        try {
            // Safety checks
            if (!code.trim()) {
                return { output: '', error: 'No code provided' };
            }

            // Choose compiler based on language
            switch (language.toLowerCase()) {
                case 'javascript':
                case 'js':
                    return this.runJavaScript(code);

                case 'typescript':
                case 'ts':
                    return await this.runTypeScript(code);

                case 'html':
                    return this.runHtml(code);

                default:
                    // For other languages, send to background script for remote compilation
                    return this.remoteCompile(code, language);
            }
        } catch (error) {
            this.logger.error('CompilerService: Compilation error', error);
            return {
                output: '',
                error: error instanceof Error ? error.message : 'Unknown error during compilation'
            };
        }
    }

    /**
     * Run JavaScript code in a sandboxed environment
     */
    private runJavaScript(code: string): CompilerResult {
        try {
            const startTime = performance.now();

            // Create a sandboxed environment
            const sandbox = this.createSandbox();

            // Add timeout protection
            const timeoutCode = `
        let __timeout_id;
        const __executeWithTimeout = () => {
          return new Promise((resolve, reject) => {
            __timeout_id = setTimeout(() => {
              reject(new Error('Execution timed out (5000ms)'));
            }, 5000);
            
            try {
              const result = (function() { ${code} })();
              clearTimeout(__timeout_id);
              resolve(result);
            } catch (error) {
              clearTimeout(__timeout_id);
              reject(error);
            }
          });
        };
        
        __executeWithTimeout();
      `;

            // Execute in the sandbox and capture console output
            const result = sandbox.eval(timeoutCode);
            const executionTime = performance.now() - startTime;

            return {
                output: sandbox.getConsoleOutput(),
                executionTime
            };
        } catch (error) {
            return {
                output: '',
                error: error instanceof Error ? error.message : 'Unknown error during execution'
            };
        }
    }

    /**
     * Run TypeScript code by transpiling then executing as JavaScript
     */
    private async runTypeScript(code: string): Promise<CompilerResult> {
        try {
            // Load TypeScript compiler from CDN if needed
            if (!(window as any).ts) {
                await this.loadTypescriptCompiler();
            }

            const ts = (window as any).ts;

            // Transpile TypeScript to JavaScript
            const transpileOutput = ts.transpileModule(code, {
                compilerOptions: {
                    module: ts.ModuleKind.ESNext,
                    target: ts.ScriptTarget.ES2020,
                    strict: false,
                    esModuleInterop: true
                }
            });

            const jsCode = transpileOutput.outputText;

            // Execute the JavaScript code
            return this.runJavaScript(jsCode);
        } catch (error) {
            return {
                output: '',
                error: error instanceof Error ? error.message : 'TypeScript compilation error'
            };
        }
    }

    /**
     * Load TypeScript compiler from CDN
     */
    private async loadTypescriptCompiler(): Promise<void> {
        return new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = 'https://cdn.jsdelivr.net/npm/typescript@5.0.4/lib/typescript.min.js';
            script.onload = () => resolve();
            script.onerror = () => reject(new Error('Failed to load TypeScript compiler'));
            document.head.appendChild(script);
        });
    }

    /**
     * Run HTML code by creating a sandboxed iframe
     */
    private runHtml(code: string): CompilerResult {
        try {
            // Create a hidden iframe for rendering HTML
            const iframe = document.createElement('iframe');
            iframe.style.display = 'none';
            document.body.appendChild(iframe);

            // Set content to the iframe
            const doc = iframe.contentDocument || iframe.contentWindow?.document;
            if (!doc) {
                throw new Error('Failed to access iframe document');
            }

            doc.open();
            doc.write(code);
            doc.close();

            // Capture console logs from the iframe
            const consoleOutput: string[] = [];
            const originalConsole = iframe.contentWindow?.console;
            if (iframe.contentWindow) {
                iframe.contentWindow.console = {
                    ...originalConsole,
                    log: (...args: any[]) => {
                        originalConsole?.log(...args);
                        consoleOutput.push(args.map(arg => String(arg)).join(' '));
                    },
                    error: (...args: any[]) => {
                        originalConsole?.error(...args);
                        consoleOutput.push(`ERROR: ${args.map(arg => String(arg)).join(' ')}`);
                    },
                    warn: (...args: any[]) => {
                        originalConsole?.warn(...args);
                        consoleOutput.push(`WARNING: ${args.map(arg => String(arg)).join(' ')}`);
                    }
                } as Console;
            }

            // Return the rendered HTML and console output
            setTimeout(() => {
                document.body.removeChild(iframe);
            }, 1000);

            return {
                output: {
                    html: doc.documentElement.outerHTML,
                    consoleOutput: consoleOutput.join('\n')
                }
            };
        } catch (error) {
            return {
                output: '',
                error: error instanceof Error ? error.message : 'HTML rendering error'
            };
        }
    }

    /**
     * Remote compile code for languages that can't be run in browser
     */
    private async remoteCompile(code: string, language: string): Promise<CompilerResult> {
        try {
            // Send to background script for remote compilation
            const response = await this.messageService.sendMessage({
                action: 'remoteCompile',
                code,
                language
            });

            if (response.success) {
                return response.data;
            } else {
                return {
                    output: '',
                    error: response.error || `Remote compilation not available for ${language}`
                };
            }
        } catch (error) {
            return {
                output: '',
                error: error instanceof Error ?
                    error.message :
                    `Remote compilation failed for ${language}`
            };
        }
    }

    /**
     * Create a sandboxed environment for executing JavaScript
     */
    private createSandbox() {
        const consoleOutput: string[] = [];

        // Create sandbox object with limited access to globals
        const sandbox = {
            console: {
                log: (...args: any[]) => {
                    consoleOutput.push(args.map(arg => this.stringifyValue(arg)).join(' '));
                },
                error: (...args: any[]) => {
                    consoleOutput.push(`ERROR: ${args.map(arg => this.stringifyValue(arg)).join(' ')}`);
                },
                warn: (...args: any[]) => {
                    consoleOutput.push(`WARNING: ${args.map(arg => this.stringifyValue(arg)).join(' ')}`);
                },
                info: (...args: any[]) => {
                    consoleOutput.push(`INFO: ${args.map(arg => this.stringifyValue(arg)).join(' ')}`);
                }
            },
            setTimeout: setTimeout.bind(window),
            clearTimeout: clearTimeout.bind(window),
            setInterval: setInterval.bind(window),
            clearInterval: clearInterval.bind(window),
            Math: Math,
            Date: Date,
            JSON: JSON,
            Object: Object,
            Array: Array,
            String: String,
            Number: Number,
            Boolean: Boolean,
            RegExp: RegExp,
            Error: Error,
            Map: Map,
            Set: Set,
            Promise: Promise,
            eval: function(code: string) {
                const fn = new Function('sandbox', `with(sandbox) { return ${code} }`);
                return fn(sandbox);
            },
            getConsoleOutput: () => consoleOutput.join('\n')
        };

        return sandbox;
    }

    /**
     * Helper to stringify complex values for console output
     */
    private stringifyValue(value: any): string {
        if (value === null) return 'null';
        if (value === undefined) return 'undefined';

        if (typeof value === 'object') {
            try {
                return JSON.stringify(value);
            } catch (e) {
                return '[Object]';
            }
        }

        return String(value);
    }
}


================================================================================
FILE: content/editor/artifactUIHandler.ts
================================================================================

import { LoggerService } from '../../shared/services/loggerService';
import { BannerService } from '../ui/bannerService';
import { EditorManager } from './editorManager';
import { CompilerService } from './compilerService';

/**
 * Handler for artifact UI interactions
 */
export class ArtifactUIHandler {
    private static instance: ArtifactUIHandler;
    private readonly logger = LoggerService.getInstance();
    private readonly bannerService = BannerService.getInstance();
    private readonly editorManager = EditorManager.getInstance();
    private readonly compilerService = CompilerService.getInstance();

    private observer: MutationObserver | null = null;

    private constructor() {
        // Private constructor for singleton
    }

    /**
     * Get the singleton instance of the artifact UI handler
     */
    public static getInstance(): ArtifactUIHandler {
        if (!ArtifactUIHandler.instance) {
            ArtifactUIHandler.instance = new ArtifactUIHandler();
        }
        return ArtifactUIHandler.instance;
    }

    /**
     * Initialize the artifact UI handler
     */
    public init(): void {
        this.startObserver();
        this.logger.debug('ArtifactUIHandler: Initialized');
    }

    /**
     * Start the mutation observer to watch for new artifacts
     */
    private startObserver(): void {
        if (this.observer) {
            this.observer.disconnect();
        }

        this.observer = new MutationObserver(this.handleDomMutations.bind(this));
        this.observer.observe(document.body, {
            childList: true,
            subtree: true
        });

        // Process existing artifacts
        this.processExistingArtifacts();
    }

    /**
     * Handle DOM mutations
     */
    private handleDomMutations(mutations: MutationRecord[]): void {
        // Only process if we have new nodes added
        const hasNewNodes = mutations.some(mutation =>
            mutation.type === 'childList' && mutation.addedNodes.length > 0);

        if (hasNewNodes) {
            // Look for new artifacts
            const addedArtifacts = mutations
                .filter(mutation => mutation.type === 'childList' && mutation.addedNodes.length > 0)
                .reduce((nodes: HTMLElement[], mutation) => {
                    mutation.addedNodes.forEach(node => {
                        if (node instanceof HTMLElement) {
                            // Check if this is an artifact container
                            if (node.classList.contains('antml-artifact-container')) {
                                nodes.push(node);
                            } else {
                                // Check for artifact containers within this node
                                const containers = node.querySelectorAll('.antml-artifact-container');
                                containers.forEach(container => nodes.push(container as HTMLElement));
                            }
                        }
                    });
                    return nodes;
                }, []);

            // Process any new artifacts found
            if (addedArtifacts.length > 0) {
                this.processNewArtifacts(addedArtifacts);
            }
        }
    }

    /**
     * Process existing artifacts in the DOM
     */
    private processExistingArtifacts(): void {
        const artifacts = document.querySelectorAll('.antml-artifact-container');

        if (artifacts.length > 0) {
            this.logger.debug(`ArtifactUIHandler: Found ${artifacts.length} existing artifacts`);
            this.processNewArtifacts(Array.from(artifacts) as HTMLElement[]);
        }
    }

    /**
     * Process new artifacts
     */
    private processNewArtifacts(artifacts: HTMLElement[]): void {
        artifacts.forEach(artifact => {
            // Skip already processed artifacts
            if (artifact.querySelector('.artifact-controls')) {
                return;
            }

            this.enhanceArtifact(artifact);
        });
    }

    /**
     * Enhance an artifact with additional controls
     */
    private enhanceArtifact(container: HTMLElement): void {
        try {
            // Find the title element to add controls next to
            const titleElement = container.querySelector('.antml-artifact-title');
            if (!titleElement) {
                return;
            }

            // Create controls container
            const controlsContainer = document.createElement('div');
            controlsContainer.className = 'artifact-controls';
            Object.assign(controlsContainer.style, {
                display: 'flex',
                gap: '8px',
                marginLeft: 'auto'
            });

            // Add edit button
            const editButton = this.createEditButton();
            controlsContainer.appendChild(editButton);

            // Add copy button
            const copyButton = this.createCopyButton();
            controlsContainer.appendChild(copyButton);

            // Add run button for code artifacts
            const isCodeArtifact = container.classList.contains('code-artifact') ||
                container.querySelector('pre code') !== null;

            if (isCodeArtifact) {
                const runButton = this.createRunButton();
                controlsContainer.appendChild(runButton);
            }

            // Add controls to the title element
            Object.assign(titleElement.style, {
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'space-between'
            });

            titleElement.appendChild(controlsContainer);

            // Store artifact data
            this.storeArtifactData(container);

            this.logger.debug('ArtifactUIHandler: Enhanced artifact', container);
        } catch (error) {
            this.logger.error('ArtifactUIHandler: Error enhancing artifact', error);
        }
    }

    /**
     * Create an edit button
     */
    private createEditButton(): HTMLButtonElement {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'artifact-edit-button';
        button.title = 'Edit this artifact';
        button.innerHTML = `
      <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
        <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
      </svg>
      <span>Edit</span>
    `;

        // Add styling
        Object.assign(button.style, {
            display: 'flex',
            alignItems: 'center',
            gap: '4px',
            padding: '4px 8px',
            borderRadius: '4px',
            border: '1px solid #e2e8f0',
            backgroundColor: '#f8fafc',
            color: '#334155',
            cursor: 'pointer',
            fontSize: '12px',
            fontWeight: '500'
        });

        // Add event listener
        button.addEventListener('click', (event) => {
            const artifactContainer = (event.target as HTMLElement)
                .closest('.antml-artifact-container') as HTMLElement;

            if (artifactContainer) {
                this.handleArtifactEdit(artifactContainer, button);
            }
        });

        return button;
    }

    /**
     * Create a copy button
     */
    private createCopyButton(): HTMLButtonElement {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'artifact-copy-button';
        button.title = 'Copy this artifact';
        button.innerHTML = `
      <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
        <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
      </svg>
      <span>Copy</span>
    `;

        // Add styling
        Object.assign(button.style, {
            display: 'flex',
            alignItems: 'center',
            gap: '4px',
            padding: '4px 8px',
            borderRadius: '4px',
            border: '1px solid #e2e8f0',
            backgroundColor: '#f8fafc',
            color: '#334155',
            cursor: 'pointer',
            fontSize: '12px',
            fontWeight: '500'
        });

        // Add event listener
        button.addEventListener('click', (event) => {
            const artifactContainer = (event.target as HTMLElement)
                .closest('.antml-artifact-container') as HTMLElement;

            if (artifactContainer) {
                this.handleArtifactCopy(artifactContainer, button);
            }
        });

        return button;
    }

    /**
     * Create a run button for code artifacts
     */
    private createRunButton(): HTMLButtonElement {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'artifact-run-button';
        button.title = 'Run this code';
        button.innerHTML = `
      <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <polygon points="5 3 19 12 5 21 5 3"></polygon>
      </svg>
      <span>Run</span>
    `;

        // Add styling
        Object.assign(button.style, {
            display: 'flex',
            alignItems: 'center',
            gap: '4px',
            padding: '4px 8px',
            borderRadius: '4px',
            border: '1px solid #d1fae5',
            backgroundColor: '#ecfdf5',
            color: '#065f46',
            cursor: 'pointer',
            fontSize: '12px',
            fontWeight: '500'
        });

        // Add event listener
        button.addEventListener('click', (event) => {
            const artifactContainer = (event.target as HTMLElement)
                .closest('.antml-artifact-container') as HTMLElement;

            if (artifactContainer) {
                this.handleArtifactRun(artifactContainer);
            }
        });

        return button;
    }

    /**
     * Store artifact data
     */
    private storeArtifactData(container: HTMLElement): void {
        // Extract metadata
        const titleElement = container.querySelector('.antml-artifact-title') as HTMLElement;
        const title = titleElement?.textContent?.trim() || 'Untitled';

        // Determine artifact type
        let type = 'text';
        if (container.classList.contains('code-artifact') || container.querySelector('pre code')) {
            type = 'code';
        } else if (container.querySelector('svg')) {
            type = 'svg';
        } else if (container.querySelector('table')) {
            type = 'table';
        }

        // Get language for code artifacts
        let language = '';
        const codeElement = container.querySelector('pre code');
        if (codeElement) {
            const classNames = Array.from(codeElement.classList);
            const langClass = classNames.find(cls => cls.startsWith('language-'));
            if (langClass) {
                language = langClass.replace('language-', '');
            }
        }

        // Store as data attribute
        container.dataset.artifactMetadata = JSON.stringify({
            title,
            type,
            language,
            timestamp: new Date().toISOString()
        });
    }

    /**
     * Handle edit button click
     */
    private async handleArtifactEdit(container: HTMLElement, button: HTMLButtonElement): Promise<void> {
        try {
            const isEditMode = container.classList.contains('editing-mode');

            if (isEditMode) {
                // Save changes
                await this.editorManager.saveChanges(container);
                button.innerHTML = `
          <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
            <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
          </svg>
          <span>Edit</span>
        `;
            } else {
                // Enter edit mode
                await this.editorManager.createEditor(container);
                button.innerHTML = `
          <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
            <polyline points="17 21 17 13 7 13 7 21"></polyline>
            <polyline points="7 3 7 8 15 8"></polyline>
          </svg>
          <span>Save</span>
        `;
            }
        } catch (error) {
            this.logger.error('ArtifactUIHandler: Edit error', error);
            this.bannerService.showError('Failed to edit artifact');
        }
    }

    /**
     * Handle copy button click
     */
    private handleArtifactCopy(container: HTMLElement, button: HTMLButtonElement): void {
        try {
            // Get content to copy
            let content = '';

            if (container.classList.contains('editing-mode')) {
                // Get from Monaco editor
                content = this.editorManager.getEditorContent(container) || '';
            } else {
                // Get from DOM
                const codeElement = container.querySelector('pre code');
                if (codeElement) {
                    content = codeElement.textContent || '';
                } else {
                    const preElement = container.querySelector('pre');
                    if (preElement) {
                        content = preElement.textContent || '';
                    } else {
                        content = container.textContent || '';
                    }
                }
            }

            // Copy to clipboard
            navigator.clipboard.writeText(content);

            // Update button temporarily
            const originalHTML = button.innerHTML;
            button.innerHTML = `
        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <polyline points="20 6 9 17 4 12"></polyline>
        </svg>
        <span>Copied!</span>
      `;

            // Reset button after delay
            setTimeout(() => {
                button.innerHTML = originalHTML;
            }, 2000);

            // Show notification
            this.bannerService.showSuccess('Copied to clipboard');
        } catch (error) {
            this.logger.error('ArtifactUIHandler: Copy error', error);
            this.bannerService.showError('Failed to copy artifact');
        }
    }

    /**
     * Handle run button click
     */
    private async handleArtifactRun(container: HTMLElement): Promise<void> {
        try {
            // Get metadata
            const metadata = this.extractArtifactMetadata(container);

            if (!metadata || metadata.type !== 'code') {
                this.bannerService.showError('Can only run code artifacts');
                return;
            }

            // Get code content
            let code: string;

            if (container.classList.contains('editing-mode')) {
                // Get from Monaco editor
                code = this.editorManager.getEditorContent(container) || '';
            } else {
                // Get from pre element
                const codeElement = container.querySelector('pre code');
                code = codeElement?.textContent || '';
            }

            if (!code.trim()) {
                this.bannerService.showError('No code to run');
                return;
            }

            // Show compiling message
            this.bannerService.showInfo('Compiling code...');

            // Run the code
            const result = await this.compilerService.compileAndRun(code, metadata.language || 'javascript');

            // Display result
            this.displayCompilationResult(container, result);
        } catch (error) {
            this.logger.error('ArtifactUIHandler: Run error', error);
            this.bannerService.showError('Failed to run code');
        }
    }

    /**
     * Extract artifact metadata
     */
    private extractArtifactMetadata(container: HTMLElement): any {
        try {
            const metadataStr = container.dataset.artifactMetadata;
            if (metadataStr) {
                return JSON.parse(metadataStr);
            }
        } catch (error) {
            this.logger.error('ArtifactUIHandler: Failed to parse metadata', error);
        }
        return null;
    }

    /**
     * Display compilation result
     */
    private displayCompilationResult(container: HTMLElement, result: any): void {
        // Check if output container already exists
        let outputContainer = container.querySelector('.compilation-output');

        if (!outputContainer) {
            // Create new output container
            outputContainer = document.createElement('div');
            outputContainer.className = 'compilation-output';
            Object.assign(outputContainer.style, {
                marginTop: '12px',
                padding: '12px',
                backgroundColor: '#f8fafc',
                borderRadius: '4px',
                border: '1px solid #e2e8f0',
                maxHeight: '300px',
                overflow: 'auto',
                fontSize: '14px',
                fontFamily: 'monospace'
            });

            container.appendChild(outputContainer);
        }

        // Clear previous content
        outputContainer.innerHTML = '';

        // Add header
        const header = document.createElement('div');
        header.style.fontWeight = 'bold';
        header.style.marginBottom = '8px';
        header.style.display = 'flex';
        header.style.justifyContent = 'space-between';
        header.innerHTML = `
      <span>Execution Results</span>
      <span class="close-output" style="cursor:pointer"></span>
    `;
        outputContainer.appendChild(header);

        // Add close button handler
        header.querySelector('.close-output')?.addEventListener('click', () => {
            outputContainer?.remove();
        });

        // Add content based on result type
        if (result.error) {
            const errorDiv = document.createElement('div');
            errorDiv.style.color = '#ef4444';
            errorDiv.textContent = result.error;
            outputContainer.appendChild(errorDiv);
        } else {
            // Create content based on result type
            if (typeof result.output === 'string') {
                const outputPre = document.createElement('pre');
                outputPre.style.margin = '0';
                outputPre.style.whiteSpace = 'pre-wrap';
                outputPre.textContent = result.output;
                outputContainer.appendChild(outputPre);
            } else {
                try {
                    const outputPre = document.createElement('pre');
                    outputPre.style.margin = '0';
                    outputPre.style.whiteSpace = 'pre-wrap';
                    outputPre.textContent = JSON.stringify(result.output, null, 2);
                    outputContainer.appendChild(outputPre);
                } catch (e) {
                    const outputDiv = document.createElement('div');
                    outputDiv.textContent = 'Complex output (cannot display)';
                    outputContainer.appendChild(outputDiv);
                }
            }
        }
    }

    /**
     * Destroy the artifact UI handler
     */
    public destroy(): void {
        if (this.observer) {
            this.observer.disconnect();
            this.observer = null;
        }

        this.logger.debug('ArtifactUIHandler: Destroyed');
    }
}


================================================================================
FILE: content/editor/editorManager.ts
================================================================================

import { MonacoEditorService } from './monacoEditorService';
import { LoggerService } from '../../shared/services/loggerService';
import { BannerService } from '../ui/bannerService';
import { StorageService } from '../../shared/services/storageService';
import { ArtifactSettings } from '../../shared/models/settings';

/**
 * Manages Monaco editors for artifacts
 */
export class EditorManager {
    private static instance: EditorManager;
    private readonly logger = LoggerService.getInstance();
    private readonly bannerService = BannerService.getInstance();
    private readonly storageService = StorageService.getInstance();
    private readonly monacoService = MonacoEditorService.getInstance();

    // Map of artifact container elements to their editor instances
    private editorMap = new Map<HTMLElement, monaco.editor.IStandaloneCodeEditor>();
    private settings: ArtifactSettings | null = null;

    private constructor() {
        this.loadSettings();
    }

    /**
     * Get the singleton instance of the editor manager
     */
    public static getInstance(): EditorManager {
        if (!EditorManager.instance) {
            EditorManager.instance = new EditorManager();
        }
        return EditorManager.instance;
    }

    /**
     * Load settings from storage
     */
    private async loadSettings(): Promise<void> {
        try {
            this.settings = await this.storageService.getSettings();
        } catch (error) {
            this.logger.error('EditorManager: Failed to load settings', error);
        }
    }

    /**
     * Create a Monaco editor for an artifact container
     */
    public async createEditor(container: HTMLElement): Promise<monaco.editor.IStandaloneCodeEditor | null> {
        if (!container) {
            this.logger.error('EditorManager: Container element is required');
            return null;
        }

        // Check if an editor already exists for this container
        if (this.editorMap.has(container)) {
            this.logger.debug('EditorManager: Editor already exists for this container');
            return this.editorMap.get(container) ?? null;
        }

        try {
            // Extract artifact metadata
            const metadata = this.extractArtifactMetadata(container);

            // Get the content to edit
            const content = this.extractArtifactContent(container);

            // Determine language from metadata or try to detect it
            const language = metadata?.language || this.detectLanguage(container, content);

            // Create editor container element
            const editorContainer = document.createElement('div');
            editorContainer.className = 'monaco-editor-container';
            Object.assign(editorContainer.style, {
                width: '100%',
                height: '300px',
                minHeight: '100px',
                border: '1px solid #e2e8f0',
                borderRadius: '4px',
                overflow: 'hidden',
                marginTop: '8px'
            });

            // Find where to insert the editor
            const codeElement = container.querySelector('pre');
            if (codeElement) {
                // Hide the original code element
                codeElement.style.display = 'none';

                // Insert editor after the code element
                codeElement.parentNode?.insertBefore(editorContainer, codeElement.nextSibling);
            } else {
                // No code element found, append to container
                container.appendChild(editorContainer);
            }

            // Ensure Monaco is loaded
            await this.monacoService.ensureMonacoLoaded();

            // Create editor with settings
            const editor = this.monacoService.createEditor(editorContainer, {
                value: content,
                language: language,
                theme: this.settings?.editorSettings.theme || 'vs',
                automaticLayout: true,
                minimap: {
                    enabled: this.settings?.editorSettings.minimap || true
                },
                lineNumbers: this.settings?.editorSettings.lineNumbers || 'on',
                wordWrap: this.settings?.editorSettings.wordWrap || 'on',
                fontSize: this.settings?.editorSettings.fontSize || 14,
                tabSize: this.settings?.editorSettings.tabSize || 2,
                insertSpaces: this.settings?.editorSettings.insertSpaces || true,
                folding: this.settings?.editorSettings.folding || true,
                scrollBeyondLastLine: false,
                roundedSelection: true,
                renderWhitespace: 'none',
                fontFamily: 'Menlo, Monaco, "Courier New", monospace',
                renderLineHighlight: 'all'
            });

            // Mark container as in editing mode
            container.classList.add('editing-mode');

            // Store editor reference
            this.editorMap.set(container, editor);

            // Add resize handle
            this.addResizeHandle(editorContainer, editor);

            // Update layout after a brief delay to ensure proper sizing
            setTimeout(() => {
                editor.layout();
                editor.focus();
            }, 100);

            this.logger.info(`EditorManager: Created editor for language ${language}`);
            return editor;
        } catch (error) {
            this.logger.error('EditorManager: Failed to create editor', error);
            this.bannerService.showError('Failed to create editor');
            return null;
        }
    }

    /**
     * Extract content from an artifact container
     */
    private extractArtifactContent(container: HTMLElement): string {
        // Try to find a code element first
        const codeElement = container.querySelector('pre code');
        if (codeElement) {
            return codeElement.textContent || '';
        }

        // Try pre element next
        const preElement = container.querySelector('pre');
        if (preElement) {
            return preElement.textContent || '';
        }

        // For SVGs, get the innerHTML of the SVG element
        const svgElement = container.querySelector('svg');
        if (svgElement) {
            return svgElement.outerHTML || '';
        }

        // For other types, get all text content
        return container.textContent || '';
    }

    /**
     * Extract metadata from an artifact container
     */
    private extractArtifactMetadata(container: HTMLElement): any {
        try {
            const metadataStr = container.dataset.artifactMetadata;
            if (metadataStr) {
                return JSON.parse(metadataStr);
            }
        } catch (error) {
            this.logger.error('EditorManager: Failed to parse artifact metadata', error);
        }
        return null;
    }

    /**
     * Detect the language from container classes or content
     */
    private detectLanguage(container: HTMLElement, content: string): string {
        // Check for code element with language class
        const codeElement = container.querySelector('pre code');
        if (codeElement) {
            const classNames = Array.from(codeElement.classList);
            const langClass = classNames.find(cls => cls.startsWith('language-'));
            if (langClass) {
                return langClass.replace('language-', '');
            }
        }

        // Check container classes
        if (container.classList.contains('code-artifact')) {
            // Try to extract language from class
            const classNames = Array.from(container.classList);
            const langClass = classNames.find(cls => cls.startsWith('language-'));
            if (langClass) {
                return langClass.replace('language-', '');
            }
        }

        // Check for SVG
        if (container.querySelector('svg') || content.trim().startsWith('<svg')) {
            return 'xml';
        }

        // Detect from content
        if (content.includes('function') || content.includes('const') || content.includes('var')) {
            return 'javascript';
        }

        if (content.includes('import ') && content.includes('from ')) {
            return 'typescript';
        }

        if (content.includes('def ') && content.includes(':')) {
            return 'python';
        }

        if (content.includes('<html>') || content.includes('<!DOCTYPE html>')) {
            return 'html';
        }

        if (content.includes('<style>') || content.includes('{') && content.includes('}')) {
            return 'css';
        }

        // Default to text
        return 'plaintext';
    }

    /**
     * Add a resize handle to the editor container
     */
    private addResizeHandle(editorContainer: HTMLElement, editor: monaco.editor.IStandaloneCodeEditor): void {
        const resizeHandle = document.createElement('div');
        resizeHandle.className = 'editor-resize-handle';
        Object.assign(resizeHandle.style, {
            height: '6px',
            background: '#e2e8f0',
            cursor: 'ns-resize',
            width: '100%',
            position: 'absolute',
            bottom: '0',
            left: '0',
            zIndex: '10'
        });

        editorContainer.appendChild(resizeHandle);
        editorContainer.style.position = 'relative';

        let startY = 0;
        let startHeight = 0;

        const onMouseDown = (e: MouseEvent) => {
            startY = e.clientY;
            startHeight = editorContainer.offsetHeight;

            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);

            e.preventDefault();
        };

        const onMouseMove = (e: MouseEvent) => {
            const newHeight = startHeight + (e.clientY - startY);
            if (newHeight >= 100) {
                editorContainer.style.height = `${newHeight}px`;
                editor.layout();
            }
        };

        const onMouseUp = () => {
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
        };

        resizeHandle.addEventListener('mousedown', onMouseDown);
    }

    /**
     * Save changes from the editor back to the artifact
     */
    public async saveChanges(container: HTMLElement): Promise<boolean> {
        const editor = this.editorMap.get(container);
        if (!editor) {
            this.logger.error('EditorManager: No editor found for this container');
            return false;
        }

        try {
            // Get updated content from editor
            const updatedContent = editor.getValue();

            // Find the original content element
            const preElement = container.querySelector('pre');
            const codeElement = container.querySelector('pre code');

            if (codeElement) {
                // Update code element content
                codeElement.textContent = updatedContent;
                // Show the original code element again
                if (preElement) {
                    preElement.style.display = '';
                }
            } else if (container.querySelector('svg')) {
                // Update SVG content - this is more complex
                try {
                    const svgContainer = container.querySelector('svg')?.parentElement;
                    if (svgContainer) {
                        svgContainer.innerHTML = updatedContent;
                    }
                } catch (e) {
                    this.logger.error('EditorManager: Failed to update SVG content', e);
                    this.bannerService.showError('Failed to update SVG: Invalid SVG syntax');
                    return false;
                }
            } else if (preElement) {
                // Update pre element content
                preElement.textContent = updatedContent;
                preElement.style.display = '';
            } else {
                // No suitable element found to update
                this.logger.warn('EditorManager: No suitable element found to update');
                this.bannerService.showWarning('Could not find element to update');
                return false;
            }

            // Remove editor
            this.removeEditor(container);

            // Show success message
            this.bannerService.showSuccess('Changes saved successfully');
            return true;
        } catch (error) {
            this.logger.error('EditorManager: Failed to save changes', error);
            this.bannerService.showError('Failed to save changes');
            return false;
        }
    }

    /**
     * Remove an editor from a container
     */
    public removeEditor(container: HTMLElement): void {
        const editor = this.editorMap.get(container);
        if (editor) {
            // Dispose of the editor
            editor.dispose();
            this.editorMap.delete(container);

            // Remove editor container
            const editorContainer = container.querySelector('.monaco-editor-container');
            editorContainer?.remove();

            // Remove editing mode class
            container.classList.remove('editing-mode');

            // Show any hidden elements
            container.querySelectorAll('pre').forEach(pre => {
                pre.style.display = '';
            });

            this.logger.debug('EditorManager: Removed editor');
        }
    }

    /**
     * Get the content of an editor
     */
    public getEditorContent(container: HTMLElement): string | null {
        const editor = this.editorMap.get(container);
        if (editor) {
            return editor.getValue();
        }
        return null;
    }

    /**
     * Dispose all editors
     */
    public disposeAll(): void {
        this.editorMap.forEach((editor, container) => {
            this.removeEditor(container);
        });
        this.editorMap.clear();
        this.logger.info('EditorManager: Disposed all editors');
    }
}


================================================================================
FILE: shared/filenameHelper.js
================================================================================

// Generates unique filenames based on directory structure preference
export function getUniqueFileName(
    title,
    language,
    messageIndex,
    usedNames,
    useDirectoryStructure,
) {
    let baseName = title.replace(/[^\w\-._]+/g, "_");
    let extension = getFileExtension(language);
    let fileName = useDirectoryStructure
        ? inferDirectoryStructure(baseName, extension)
        : `${messageIndex + 1}_${baseName}${extension}`;

    let suffix = "";
    let suffixCount = 1;
    while (usedNames.has(fileName + suffix)) {
        suffix = `_${"*".repeat(suffixCount++)}`;
    }

    fileName += suffix;
    usedNames.add(fileName);
    return fileName;
}

function inferDirectoryStructure(baseName, extension, messageIndex = null) {
    const parts = baseName.split("/");
    const fileName = parts.pop() + extension;
    const directory = parts.join("/");
    return messageIndex !== null
        ? `${directory}/${messageIndex + 1}_${fileName}`
        : `${directory}/${fileName}`;
}

function getFileExtension(language) {
    const map = {
        js: ".js", python: ".py", java: ".java", txt: ".txt",
        // add other languages as needed
    };
    return map[language.toLowerCase()] || ".txt";
}


================================================================================
FILE: shared/zipCreator.js
================================================================================

// Creates a JSZip instance and returns blob asynchronously
export async function createZip(artifacts) {
    const zip = new JSZip();
    artifacts.forEach(({ filename, content }) => {
        zip.file(filename, content);
    });
    return zip.generateAsync({ type: "blob" });
}


================================================================================
FILE: shared/artifactExtractor.js
================================================================================

// Extract artifacts from Claude's responses
export function extractArtifacts(text) {
    const artifactRegex = /<antArtifact[^>]*>([\s\S]*?)<\/antArtifact>/g;
    const artifacts = [];
    let match;

    while ((match = artifactRegex.exec(text)) !== null) {
        const fullTag = match[0];
        const content = match[1];

        const titleMatch = fullTag.match(/title="([^"]*)/);
        const languageMatch = fullTag.match(/language="([^"]*)/);

        artifacts.push({
            title: titleMatch ? titleMatch[1] : "Untitled",
            language: languageMatch ? languageMatch[1] : "txt",
            content: content.trim(),
        });
    }

    return artifacts;
}


================================================================================
FILE: shared/utils/artifactExtractor.ts
================================================================================

import { Artifact, ArtifactType } from '../models/artifact';
import { LoggerService } from '../services/loggerService';

/**
 * Utility for extracting artifacts from Claude responses
 */
export class ArtifactExtractor {
    private static readonly logger = LoggerService.getInstance();

    /**
     * Extract artifacts from HTML DOM
     */
    public static extractArtifactsFromDOM(containerSelector: string = '.conversation-container'): Artifact[] {
        try {
            const container = document.querySelector(containerSelector);
            if (!container) {
                this.logger.warn('ArtifactExtractor: Container not found');
                return [];
            }

            const artifacts: Artifact[] = [];

            // Find all artifact containers
            const artifactContainers = container.querySelectorAll('.antml-artifact-container');

            artifactContainers.forEach((container: Element, index: number) => {
                try {
                    const artifact = this.extractArtifactFromContainer(container as HTMLElement);
                    if (artifact) {
                        artifacts.push(artifact);
                    }
                } catch (error) {
                    this.logger.error(`ArtifactExtractor: Error extracting artifact at index ${index}`, error);
                }
            });

            return artifacts;
        } catch (error) {
            this.logger.error('ArtifactExtractor: Error extracting artifacts from DOM', error);
            return [];
        }
    }

    /**
     * Extract an artifact from a container element
     */
    private static extractArtifactFromContainer(container: HTMLElement): Artifact | null {
        if (!container) return null;

        try {
            // Extract title
            const titleElement = container.querySelector('.antml-artifact-title');
            const title = titleElement?.textContent?.trim() || 'Untitled Artifact';

            // Generate ID
            const id = `artifact-${Date.now()}-${Math.floor(Math.random() * 1000)}`;

            // Determine type and extract content
            let type = ArtifactType.UNKNOWN;
            let content = '';
            let language: string | undefined;

            // Check for code artifact
            const codeElement = container.querySelector('pre code');
            if (codeElement) {
                type = ArtifactType.CODE;
                content = codeElement.textContent || '';

                // Try to get language from class
                const classNames = Array.from(codeElement.classList);
                const langClass = classNames.find(cls => cls.startsWith('language-'));
                if (langClass) {
                    language = langClass.replace('language-', '');
                }
            }
            // Check for SVG
            else if (container.querySelector('svg')) {
                type = ArtifactType.SVG;
                const svgElement = container.querySelector('svg');
                content = svgElement?.outerHTML || '';
            }
            // Check for Mermaid
            else if (container.classList.contains('mermaid-artifact')) {
                type = ArtifactType.MERMAID;
                content = container.textContent || '';
            }
            // Check for React
            else if (container.classList.contains('react-artifact')) {
                type = ArtifactType.REACT;
                content = container.textContent || '';
            }
            // Check for HTML
            else if (container.classList.contains('html-artifact')) {
                type = ArtifactType.HTML;
                content = container.querySelector('div')?.innerHTML || '';
            }
            // Default to Markdown for text
            else {
                type = ArtifactType.MARKDOWN;
                content = container.textContent || '';
            }

            return {
                id,
                title,
                content,
                type,
                language,
                timestamp: new Date().toISOString()
            };
        } catch (error) {
            this.logger.error('ArtifactExtractor: Error extracting artifact from container', error);
            return null;
        }
    }

    /**
     * Stitch together artifacts with the same title and type
     */
    public static stitchArtifacts(artifacts: Artifact[]): Artifact[] {
        if (!artifacts || artifacts.length <= 1) return artifacts;

        try {
            const stitchedArtifacts: Artifact[] = [];
            const artifactGroups = new Map<string, Artifact[]>();

            // Group artifacts by title and type
            artifacts.forEach(artifact => {
                const key = `${artifact.title}-${artifact.type}${artifact.language ? `-${artifact.language}` : ''}`;

                if (!artifactGroups.has(key)) {
                    artifactGroups.set(key, []);
                }

                artifactGroups.get(key)?.push(artifact);
            });

            // Process each group
            artifactGroups.forEach((group, key) => {
                if (group.length === 1) {
                    // Single artifact, no stitching needed
                    stitchedArtifacts.push(group[0]);
                } else {
                    // Multiple artifacts with same title, stitch them
                    this.logger.info(`ArtifactExtractor: Stitching ${group.length} artifacts for key: ${key}`);

                    // Sort by timestamp if available
                    group.sort((a, b) => {
                        if (a.timestamp && b.timestamp) {
                            return new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime();
                        }
                        return 0;
                    });

                    // Combine content
                    const stitched: Artifact = {
                        ...group[0],
                        content: group.map(a => a.content).join('\n'),
                        partOfSeries: true,
                        seriesPosition: 1,
                        seriesTotal: group.length
                    };

                    stitchedArtifacts.push(stitched);
                }
            });

            return stitchedArtifacts;
        } catch (error) {
            this.logger.error('ArtifactExtractor: Error stitching artifacts', error);
            return artifacts;
        }
    }
}


================================================================================
FILE: shared/utils/filenameHelper.ts
================================================================================

import { Artifact } from '../models/artifact';
import { LoggerService } from '../services/loggerService';

/**
 * Helper for generating filenames for artifacts
 */
export class FilenameHelper {
    private static readonly logger = LoggerService.getInstance();

    /**
     * Map artifact types to appropriate file extensions
     */
    private static readonly extensionMap: Record<string, string> = {
        code: '', // determined by language
        markdown: '.md',
        html: '.html',
        svg: '.svg',
        mermaid: '.mmd',
        react: '.jsx',
        unknown: '.txt'
    };

    /**
     * Map language to file extensions
     */
    private static readonly languageExtensionMap: Record<string, string> = {
        javascript: '.js',
        typescript: '.ts',
        python: '.py',
        java: '.java',
        csharp: '.cs',
        cpp: '.cpp',
        c: '.c',
        ruby: '.rb',
        go: '.go',
        php: '.php',
        sql: '.sql',
        rust: '.rs',
        swift: '.swift',
        kotlin: '.kt',
        scala: '.scala',
        dart: '.dart',
        json: '.json',
        yaml: '.yaml',
        xml: '.xml',
        css: '.css',
        scss: '.scss',
        less: '.less',
        bash: '.sh',
        powershell: '.ps1',
        plaintext: '.txt'
    };

    /**
     * Get a safe filename for an artifact
     */
    public static getFilename(
        artifact: Artifact,
        includeTimestamp: boolean = true,
        replaceInvalidChars: boolean = true,
        maxLength: number = 255
    ): string {
        try {
            // Start with artifact title
            let filename = artifact.title || 'untitled';

            // Add timestamp if requested
            if (includeTimestamp && artifact.timestamp) {
                const date = new Date(artifact.timestamp);
                const timestamp = date.toISOString().replace(/[:.]/g, '-').slice(0, 19);
                filename = `${filename}_${timestamp}`;
            }

            // Make filename safe
            if (replaceInvalidChars) {
                filename = this.sanitizeFilename(filename, true);
            } else {
                filename = this.sanitizeFilename(filename, false);
            }

            // Add appropriate extension
            const extension = this.getExtension(artifact);

            // Ensure filename is not too long
            const maxBaseLength = maxLength - extension.length;
            if (filename.length > maxBaseLength) {
                filename = filename.slice(0, maxBaseLength);
            }

            return `${filename}${extension}`;
        } catch (error) {
            this.logger.error('FilenameHelper: Error generating filename', error);
            return `artifact-${Date.now()}.txt`;
        }
    }

    /**
     * Get file extension for an artifact
     */
    private static getExtension(artifact: Artifact): string {
        if (artifact.type === 'code' && artifact.language) {
            return this.languageExtensionMap[artifact.language.toLowerCase()] || '.txt';
        }

        return this.extensionMap[artifact.type] || '.txt';
    }

    /**
     * Sanitize a filename to be safe for file systems
     */
    private static sanitizeFilename(name: string, replaceChars: boolean = true): string {
        // Remove or replace unsafe characters
        if (replaceChars) {
            // Replace unsafe characters with underscores
            return name
                .replace(/[<>:"/\\|?*]/g, '_') // Replace Windows unsafe chars
                .replace(/\s+/g, '_')          // Replace spaces with underscores
                .replace(/\.\./g, '_')         // Replace .. to prevent directory traversal
                .replace(/^[.-]+/, '')         // Remove leading dots and dashes
                .replace(/[.-]+$/, '');        // Remove trailing dots and dashes
        } else {
            // Remove unsafe characters
            return name
                .replace(/[<>:"/\\|?*]/g, '')  // Remove Windows unsafe chars
                .replace(/\s+/g, '_')          // Replace spaces with underscores
                .replace(/\.\./g, '_')         // Replace .. to prevent directory traversal
                .replace(/^[.-]+/, '')         // Remove leading dots and dashes
                .replace(/[.-]+$/, '');        // Remove trailing dots and dashes
        }
    }

    /**
     * Generate folder path for an artifact in structured storage
     */
    public static getFolderPath(artifact: Artifact, conversationTitle?: string): string {
        try {
            // Get date from artifact timestamp or current time
            const date = artifact.timestamp ? new Date(artifact.timestamp) : new Date();

            // Format year and month
            const year = date.getFullYear();
            const month = (date.getMonth() + 1).toString().padStart(2, '0');

            // Base path using date
            let path = `${year}/${month}`;

            // Add conversation title if available
            if (conversationTitle) {
                const safeFolderName = this.sanitizeFilename(conversationTitle);
                path = `${path}/${safeFolderName}`;
            }

            return path;
        } catch (error) {
            this.logger.error('FilenameHelper: Error generating folder path', error);
            return 'artifacts';
        }
    }
}


================================================================================
FILE: shared/utils/zipCreator.ts
================================================================================

import { ArtifactFile } from '../models/artifact';
import { LoggerService } from '../services/loggerService';

/**
 * Helper for creating ZIP archives of artifacts
 */
export class ZipCreator {
    private static readonly logger = LoggerService.getInstance();

    /**
     * Create a ZIP file from a list of artifact files
     */
    public static async createZip(files: ArtifactFile[]): Promise<Blob> {
        try {
            // Ensure JSZip is loaded
            const JSZip = await this.loadJSZip();

            // Create a new ZIP archive
            const zip = new JSZip();

            // Add files to the ZIP
            for (const file of files) {
                const path = file.path ? `${file.path}/${file.filename}` : file.filename;

                // Add content to ZIP (Blob or string)
                if (file.content instanceof Blob) {
                    zip.file(path, file.content);
                } else {
                    zip.file(path, file.content);
                }
            }

            // Generate ZIP file
            const zipBlob = await zip.generateAsync({
                type: 'blob',
                compression: 'DEFLATE',
                compressionOptions: {
                    level: 9
                }
            });

            return zipBlob;
        } catch (error) {
            this.logger.error('ZipCreator: Error creating ZIP file', error);
            throw error;
        }
    }

    /**
     * Load JSZip library from CDN if not already loaded
     */
    private static async loadJSZip(): Promise<typeof JSZip> {
        // Check if JSZip is already loaded
        if ((window as any).JSZip) {
            return (window as any).JSZip;
        }

        // Load JSZip from CDN
        this.logger.debug('ZipCreator: Loading JSZip from CDN');

        return new Promise<typeof JSZip>((resolve, reject) => {
            const script = document.createElement('script');
            script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
            script.onload = () => {
                this.logger.debug('ZipCreator: JSZip loaded successfully');
                resolve((window as any).JSZip);
            };
            script.onerror = () => {
                const error = new Error('Failed to load JSZip library');
                this.logger.error('ZipCreator: JSZip load error', error);
                reject(error);
            };
            document.head.appendChild(script);
        });
    }
}


================================================================================
FILE: shared/models/editor.ts
================================================================================

/**
 * Types related to the Monaco Editor integration
 */

export interface IEditorInstance {
    id: string;
    editor: monaco.editor.IStandaloneCodeEditor;
    language: string;
    originalContent: string;
    isDirty: boolean;
}

export interface ICompilationResult {
    success: boolean;
    output?: string;
    error?: string;
    language: string;
    executionTime?: number;
}

export interface IEditorOptions {
    theme?: string;
    fontSize?: number;
    wordWrap?: 'on' | 'off';
    lineNumbers?: 'on' | 'off';
    minimap?: {
        enabled: boolean;
    };
}

export interface IMonacoEditorService {
    /**
     * Initialize the Monaco Editor
     * @returns Promise that resolves when initialization is complete
     */
    initialize(): Promise<void>;

    /**
     * Create a new editor instance
     * @param container DOM element to contain the editor
     * @param content Initial content
     * @param language Programming language
     * @param id Unique identifier for the editor
     * @param options Editor options
     */
    createEditor(
        container: HTMLElement,
        content: string,
        language: string,
        id: string,
        options?: IEditorOptions
    ): Promise<monaco.editor.IStandaloneCodeEditor | null>;

    /**
     * Get content from an editor
     * @param id Editor ID
     */
    getContent(id: string): string | null;

    /**
     * Update the content of an editor
     * @param id Editor ID
     * @param content New content
     */
    updateContent(id: string, content: string): boolean;

    /**
     * Dispose of an editor instance
     * @param id Editor ID
     */
    disposeEditor(id: string): void;

    /**
     * Dispose of all editor instances
     */
    disposeAll(): void;

    /**
     * Check if an editor with the given ID exists
     * @param id Editor ID
     */
    hasEditor(id: string): boolean;
}

export interface ICompilerService {
    /**
     * Compile and run code
     * @param code The code to compile/run
     * @param language The programming language
     */
    compileAndRun(code: string, language: string): Promise<ICompilationResult>;

    /**
     * Check if a language is supported for compilation
     * @param language The programming language to check
     */
    isLanguageSupported(language: string): boolean;
}


================================================================================
FILE: shared/models/settings.ts
================================================================================

/**
 * Settings model for the Claude Artifacts extension
 */

/**
 * Main settings interface for artifact handling
 */
export interface ArtifactSettings {
    /**
     * Whether to automatically combine artifacts with the same title/type that may have been split
     * due to Claude response limitations
     */
    stitchArtifacts: boolean;

    /**
     * Whether to save all files in a flat structure (true) or organize by conversation/date (false)
     */
    flatFileStructure: boolean;

    /**
     * Whether to include the timestamp in filenames
     */
    includeTimestampInFilename: boolean;

    /**
     * Whether to replace invalid filename characters (true) or just remove them (false)
     */
    replaceInvalidChars: boolean;

    /**
     * Maximum filename length (including extension)
     */
    maxFilenameLength: number;

    /**
     * API-related settings
     */
    apiSettings: ApiSettings;

    /**
     * Monaco editor settings
     */
    editorSettings: EditorSettings;

    /**
     * Compiler settings
     */
    compilerSettings: CompilerSettings;

    /**
     * UI settings
     */
    uiSettings: UISettings;

    /**
     * The version of the settings schema, for handling migrations
     */
    version: number;
}

/**
 * Settings for Claude API access
 */
export interface ApiSettings {
    /**
     * Whether to enable API continuation when rate limited
     */
    enableApiContinuation: boolean;

    /**
     * Claude API key (stored encrypted)
     */
    apiKey: string;

    /**
     * API endpoint for Claude conversations
     */
    apiEndpoint: string;

    /**
     * The model to use for API requests
     */
    modelName: string;

    /**
     * Max tokens to generate in API responses
     */
    maxTokens: number;

    /**
     * Temperature setting for API requests
     */
    temperature: number;
}

/**
 * Settings for the Monaco code editor
 */
export interface EditorSettings {
    /**
     * Theme for the Monaco editor
     */
    theme: 'vs' | 'vs-dark' | 'hc-black';

    /**
     * Font size for the editor
     */
    fontSize: number;

    /**
     * Line numbers visibility
     */
    lineNumbers: 'on' | 'off' | 'relative';

    /**
     * Word wrap settings
     */
    wordWrap: 'off' | 'on' | 'wordWrapColumn' | 'bounded';

    /**
     * Whether to enable minimap
     */
    minimap: boolean;

    /**
     * Tab size
     */
    tabSize: number;

    /**
     * Insert spaces when pressing Tab
     */
    insertSpaces: boolean;

    /**
     * Whether to enable auto bracket pairs
     */
    autoClosingBrackets: boolean;

    /**
     * Whether to auto indent when pressing Enter
     */
    autoIndent: boolean;

    /**
     * Whether to enable code folding
     */
    folding: boolean;

    /**
     * Whether to automatically load editor for all code artifacts
     */
    autoLoadForCode: boolean;
}

/**
 * Settings for the code compiler/runner
 */
export interface CompilerSettings {
    /**
     * Whether to enable the code compilation feature
     */
    enableCompilation: boolean;

    /**
     * Whether to use a local sandbox or remote compilation service
     */
    useRemoteCompilation: boolean;

    /**
     * Endpoint for remote compilation if enabled
     */
    remoteCompilationEndpoint: string;

    /**
     * Timeout in milliseconds for code execution
     */
    executionTimeoutMs: number;

    /**
     * Whether to show line numbers in compiler output
     */
    showLineNumbers: boolean;

    /**
     * Whether to show execution time in compiler output
     */
    showExecutionTime: boolean;

    /**
     * Languages supported for compilation
     */
    supportedLanguages: string[];

    /**
     * API key for remote compilation service (stored encrypted)
     */
    compilationApiKey: string;
}

/**
 * Settings for UI customization
 */
export interface UISettings {
    /**
     * Whether to show the download button
     */
    showDownloadButton: boolean;

    /**
     * Whether to show the settings button
     */
    showSettingsButton: boolean;

    /**
     * Whether to show the edit button on artifacts
     */
    showEditButton: boolean;

    /**
     * Whether to show the run button on code artifacts
     */
    showRunButton: boolean;

    /**
     * Whether to show success/error notifications
     */
    showNotifications: boolean;

    /**
     * Duration in milliseconds to show notifications
     */
    notificationDurationMs: number;

    /**
     * Whether to show confirmation dialogs for actions
     */
    showConfirmations: boolean;

    /**
     * Custom CSS for UI elements
     */
    customCSS: string;
}

/**
 * UI element references used internally
 */
export interface UIElements {
    downloadButton: HTMLButtonElement | null;
    settingsButton: HTMLButtonElement | null;
    headerContainer: HTMLElement | null;
}

/**
 * Default settings object
 */
export const DEFAULT_SETTINGS: ArtifactSettings = {
    stitchArtifacts: true,
    flatFileStructure: false,
    includeTimestampInFilename: true,
    replaceInvalidChars: true,
    maxFilenameLength: 255,
    apiSettings: {
        enableApiContinuation: false,
        apiKey: '',
        apiEndpoint: 'https://api.anthropic.com/v1/messages',
        modelName: 'claude-3-haiku-20240307',
        maxTokens: 4096,
        temperature: 0.7
    },
    editorSettings: {
        theme: 'vs',
        fontSize: 14,
        lineNumbers: 'on',
        wordWrap: 'on',
        minimap: true,
        tabSize: 2,
        insertSpaces: true,
        autoClosingBrackets: true,
        autoIndent: true,
        folding: true,
        autoLoadForCode: false
    },
    compilerSettings: {
        enableCompilation: true,
        useRemoteCompilation: true,
        remoteCompilationEndpoint: 'https://api.compilers.io',
        executionTimeoutMs: 5000,
        showLineNumbers: true,
        showExecutionTime: true,
        supportedLanguages: [
            'javascript', 'typescript', 'python', 'java', 'c', 'cpp', 'csharp',
            'go', 'rust', 'php', 'ruby', 'swift', 'kotlin', 'scala'
        ],
        compilationApiKey: ''
    },
    uiSettings: {
        showDownloadButton: true,
        showSettingsButton: true,
        showEditButton: true,
        showRunButton: true,
        showNotifications: true,
        notificationDurationMs: 3000,
        showConfirmations: true,
        customCSS: ''
    },
    version: 1
};


================================================================================
FILE: shared/models/artifact.ts
================================================================================

/**
 * Types of artifacts that can be extracted from Claude responses
 */
export enum ArtifactType {
    CODE = 'code',
    MARKDOWN = 'markdown',
    HTML = 'html',
    SVG = 'svg',
    MERMAID = 'mermaid',
    REACT = 'react',
    UNKNOWN = 'unknown'
}

/**
 * Interface for an extracted artifact from Claude
 */
export interface Artifact {
    /**
     * Unique identifier for the artifact
     */
    id: string;

    /**
     * Display title of the artifact
     */
    title: string;

    /**
     * Content of the artifact
     */
    content: string;

    /**
     * Type of the artifact
     */
    type: ArtifactType;

    /**
     * Programming language for code artifacts
     */
    language?: string;

    /**
     * Timestamp when the artifact was extracted
     */
    timestamp: string;

    /**
     * Conversation ID this artifact belongs to
     */
    conversationId?: string;

    /**
     * Message ID this artifact belongs to
     */
    messageId?: string;

    /**
     * Whether this artifact is part of a series that needs stitching
     */
    partOfSeries?: boolean;

    /**
     * Position in the series if part of one
     */
    seriesPosition?: number;

    /**
     * Total number of parts in the series
     */
    seriesTotal?: number;
}

/**
 * Interface for artifact file information for downloading
 */
export interface ArtifactFile {
    /**
     * Filename to use for the artifact
     */
    filename: string;

    /**
     * Content of the file
     */
    content: string | Blob;

    /**
     * Path within the archive (for structured organization)
     */
    path?: string;

    /**
     * Original artifact reference
     */
    artifact: Artifact;
}

/**
 * Information about a conversation that contains artifacts
 */
export interface ConversationInfo {
    /**
     * Unique ID of the conversation
     */
    id: string;

    /**
     * Title of the conversation
     */
    title: string;

    /**
     * Timestamp of the conversation
     */
    timestamp: string;

    /**
     * Number of artifacts in the conversation
     */
    artifactCount: number;
}


================================================================================
FILE: shared/services/loggerService.ts
================================================================================

/**
 * Logger service for consistent logging throughout the extension
 */
export enum LogLevel {
    DEBUG = 0,
    INFO = 1,
    WARN = 2,
    ERROR = 3,
    NONE = 4
}

/**
 * Service for logging messages at different levels with consistent formatting
 */
export class LoggerService {
    private static instance: LoggerService;
    private logLevel: LogLevel = LogLevel.INFO;
    private readonly prefix = '[Claude Artifacts]';
    private readonly isProduction = process.env.NODE_ENV === 'production';

    private constructor() {
        // Private constructor for singleton
        if (this.isProduction) {
            this.logLevel = LogLevel.WARN;
        }
    }

    /**
     * Get the singleton instance of the logger
     */
    public static getInstance(): LoggerService {
        if (!LoggerService.instance) {
            LoggerService.instance = new LoggerService();
        }
        return LoggerService.instance;
    }

    /**
     * Set the minimum log level to display
     */
    public setLogLevel(level: LogLevel): void {
        this.logLevel = level;
    }

    /**
     * Log a debug message
     */
    public debug(message: string, ...args: any[]): void {
        if (this.logLevel <= LogLevel.DEBUG) {
            console.debug(`${this.prefix} ${message}`, ...args);
        }
    }

    /**
     * Log an info message
     */
    public info(message: string, ...args: any[]): void {
        if (this.logLevel <= LogLevel.INFO) {
            console.info(`${this.prefix} ${message}`, ...args);
        }
    }

    /**
     * Log a warning message
     */
    public warn(message: string, ...args: any[]): void {
        if (this.logLevel <= LogLevel.WARN) {
            console.warn(`${this.prefix} ${message}`, ...args);
        }
    }

    /**
     * Log an error message
     */
    public error(message: string, ...args: any[]): void {
        if (this.logLevel <= LogLevel.ERROR) {
            console.error(`${this.prefix} ${message}`, ...args);
        }
    }

    /**
     * Create a group in the console for related logs
     */
    public group(label: string): void {
        if (this.logLevel < LogLevel.NONE) {
            console.group(`${this.prefix} ${label}`);
        }
    }

    /**
     * End a console group
     */
    public groupEnd(): void {
        if (this.logLevel < LogLevel.NONE) {
            console.groupEnd();
        }
    }

    /**
     * Measure performance between points
     */
    public time(label: string): void {
        if (this.logLevel <= LogLevel.DEBUG) {
            console.time(`${this.prefix} ${label}`);
        }
    }

    /**
     * End performance measurement
     */
    public timeEnd(label: string): void {
        if (this.logLevel <= LogLevel.DEBUG) {
            console.timeEnd(`${this.prefix} ${label}`);
        }
    }
}



================================================================================
FILE: background/background.js
================================================================================

import "./messageRouter.js";

chrome.runtime.onInstalled.addListener(() => {
    console.log("Claude Downloader Extension Installed.");
});


================================================================================
FILE: background/apiFetchService.js
================================================================================

export async function fetchChatData(details) {
    const headers = details.requestHeaders.reduce((acc, h) => {
        acc[h.name] = h.value;
        return acc;
    }, {});

    headers["X-Own-Request"] = "true";

    const resp = await fetch(details.url, {
        method: details.method,
        headers,
        credentials: "include",
    });

    return resp.ok ? resp.json() : null;
}


================================================================================
FILE: background/messageRouter.js
================================================================================

import { handleDownloadArtifacts } from "./artifactService.js";

chrome.runtime.onMessage.addListener((request, sender) => {
    switch (request.action) {
        case "downloadArtifacts":
            handleDownloadArtifacts(request, sender);
            break;
        default:
            console.warn(`Unhandled action: ${request.action}`);
    }
});


================================================================================
FILE: background/storageService.ts
================================================================================

import { ArtifactSettings, DEFAULT_SETTINGS } from '../models/settings';
import { LoggerService } from './loggerService';

/**
 * Service for interacting with Chrome storage
 */
export class StorageService {
    private static instance: StorageService;
    private readonly logger = LoggerService.getInstance();

    private constructor() {
        // Private constructor for singleton
    }

    /**
     * Get the singleton instance of the storage service
     */
    public static getInstance(): StorageService {
        if (!StorageService.instance) {
            StorageService.instance = new StorageService();
        }
        return StorageService.instance;
    }

    /**
     * Get the user settings from storage or return defaults
     */
    public async getSettings(): Promise<ArtifactSettings> {
        try {
            const result = await chrome.storage.sync.get('artifactSettings');

            if (result.artifactSettings) {
                // Handle potential schema upgrades here
                const storedSettings = result.artifactSettings as ArtifactSettings;
                const currentVersion = DEFAULT_SETTINGS.version;

                if (storedSettings.version !== currentVersion) {
                    this.logger.info(`Migrating settings from version ${storedSettings.version} to ${currentVersion}`);
                    return this.migrateSettings(storedSettings, currentVersion);
                }

                return storedSettings;
            } else {
                // No settings found, save and return defaults
                await this.saveSettings(DEFAULT_SETTINGS);
                return DEFAULT_SETTINGS;
            }
        } catch (error) {
            this.logger.error('Failed to get settings', error);
            return DEFAULT_SETTINGS;
        }
    }

    /**
     * Save settings to storage
     */
    public async saveSettings(settings: ArtifactSettings): Promise<boolean> {
        try {
            await chrome.storage.sync.set({ artifactSettings: settings });
            this.logger.debug('Settings saved successfully');
            return true;
        } catch (error) {
            this.logger.error('Failed to save settings', error);
            return false;
        }
    }

    /**
     * Update specific settings and save
     */
    public async updateSettings(partialSettings: Partial<ArtifactSettings>): Promise<boolean> {
        try {
            const currentSettings = await this.getSettings();
            const updatedSettings = {
                ...currentSettings,
                ...partialSettings
            };
            return this.saveSettings(updatedSettings);
        } catch (error) {
            this.logger.error('Failed to update settings', error);
            return false;
        }
    }

    /**
     * Migrate settings from a previous version
     */
    private migrateSettings(oldSettings: ArtifactSettings, newVersion: number): ArtifactSettings {
        // Start with current defaults
        const newSettings = { ...DEFAULT_SETTINGS };

        // Copy over as many properties as possible from old settings
        Object.keys(newSettings).forEach(key => {
            if (key in oldSettings && key !== 'version') {
                (newSettings as any)[key] = (oldSettings as any)[key];
            }
        });

        // Set the new version
        newSettings.version = newVersion;

        // Save the migrated settings
        this.saveSettings(newSettings).catch(error => {
            this.logger.error('Failed to save migrated settings', error);
        });

        return newSettings;
    }

    /**
     * Save an artifact to local storage (used for stitching)
     */
    public async saveArtifact(key: string, data: any): Promise<void> {
        try {
            await chrome.storage.local.set({ [key]: data });
            this.logger.debug(`Artifact saved: ${key}`);
        } catch (error) {
            this.logger.error(`Failed to save artifact: ${key}`, error);
            throw error;
        }
    }

    /**
     * Get an artifact from local storage
     */
    public async getArtifact(key: string): Promise<any> {
        try {
            const result = await chrome.storage.local.get(key);
            return result[key];
        } catch (error) {
            this.logger.error(`Failed to get artifact: ${key}`, error);
            throw error;
        }
    }

    /**
     * Remove an artifact from local storage
     */
    public async removeArtifact(key: string): Promise<void> {
        try {
            await chrome.storage.local.remove(key);
            this.logger.debug(`Artifact removed: ${key}`);
        } catch (error) {
            this.logger.error(`Failed to remove artifact: ${key}`, error);
            throw error;
        }
    }

    /**
     * Clear all stored artifacts (but keep settings)
     */
    public async clearArtifacts(): Promise<void> {
        try {
            await chrome.storage.local.clear();
            this.logger.info('All artifacts cleared from storage');
        } catch (error) {
            this.logger.error('Failed to clear artifacts', error);
            throw error;
        }
    }
}


================================================================================
FILE: background/downloadService.js
================================================================================

const downloadService = {
    async downloadZip(blob, filename) {
        const url = URL.createObjectURL(blob);
        chrome.downloads.download({ url, filename, saveAs: true }, () => {
            URL.revokeObjectURL(url);
        });
    },
};

export default downloadService;


================================================================================
FILE: background/artifactService.js
================================================================================

import storageService from "./storageService.js";
import downloadService from "./downloadService.js";
import { extractArtifacts } from "../shared/artifactExtractor.js";
import { getUniqueFileName } from "../shared/filenameHelper.js";
import { createZip } from "../shared/zipCreator.js";

export async function handleDownloadArtifacts(request, sender) {
    const payload = await storageService.getChatPayload(request.uuid);
    if (!payload) {
        notifyTab(sender.tab.id, false, "No payload found, try refreshing.");
        return;
    }

    const artifacts = [];
    const usedNames = new Set();

    payload.chat_messages.forEach((message, index) => {
        if (message.sender !== "assistant" || !message.text) return;

        const extracted = extractArtifacts(message.text);
        extracted.forEach((artifact) => {
            artifacts.push({
                filename: getUniqueFileName(
                    artifact.title,
                    artifact.language,
                    index,
                    usedNames,
                    request.useDirectoryStructure
                ),
                content: artifact.content,
            });
        });
    });

    if (!artifacts.length) {
        notifyTab(sender.tab.id, false, "No artifacts in this conversation.");
        return;
    }

    const zipBlob = await createZip(artifacts);
    await downloadService.downloadZip(zipBlob, `${payload.name}.zip`);
    notifyTab(sender.tab.id, true, `${artifacts.length} artifacts downloaded.`);
}

function notifyTab(tabId, success, message) {
    chrome.tabs.sendMessage(tabId, {
        action: "artifactsProcessed",
        success,
        message,
    });
}


================================================================================
FILE: background/index.ts
================================================================================

import { LoggerService } from '../shared/services/loggerService';
import { StorageService } from '../shared/services/storageService';
import { ArtifactService } from './services/artifactService';
import { DownloadService } from './services/downloadService';
import { MessageRouter } from './services/messageRouter';
import { ApiService } from './services/apiService';

/**
 * Main entry point for the background script
 */
class Background {
    private readonly logger = LoggerService.getInstance();
    private readonly storageService = StorageService.getInstance();
    private readonly artifactService = ArtifactService.getInstance();
    private readonly downloadService = DownloadService.getInstance();
    private readonly apiService = ApiService.getInstance();
    private readonly messageRouter = MessageRouter.getInstance();

    constructor() {
        this.init().catch(error => {
            console.error('Background: Initialization error', error);
        });
    }

    /**
     * Initialize the background script
     */
    private async init(): Promise<void> {
        try {
            this.logger.info('Background: Initializing');

            // Load settings
            await this.storageService.getSettings();

            // Initialize services
            this.messageRouter.init();
            this.artifactService.init();
            this.downloadService.init();
            this.apiService.init();

            // Set up extension icon click handler
            chrome.action.onClicked.addListener(this.handleActionClick.bind(this));

            this.logger.info('Background: Initialization complete');
        } catch (error) {
            this.logger.error('Background: Initialization failed', error);
        }
    }

    /**
     * Handle extension icon click
     */
    private async handleActionClick(tab: chrome.tabs.Tab): Promise<void> {
        if (!tab.id) return;

        try {
            // Check if on Claude site
            const url = tab.url || '';
            if (!url.includes('claude.ai') && !url.includes('anthropic.com')) {
                await chrome.tabs.create({ url: 'https://claude.ai/' });
                return;
            }

            // Send message to show settings
            chrome.tabs.sendMessage(tab.id, { action: 'showSettings' });
        } catch (error) {
            this.logger.error('Background: Error handling action click', error);
        }
    }
}

// Initialize background script
new Background();


================================================================================
FILE: background/services/downloadService.ts
================================================================================

import { ArtifactFile } from '../../shared/models/artifact';
import { LoggerService } from '../../shared/services/loggerService';
import { ZipCreator } from '../../shared/utils/zipCreator';

/**
 * Service for downloading artifacts
 */
export class DownloadService {
    private static instance: DownloadService;
    private readonly logger = LoggerService.getInstance();

    private constructor() {
        // Private constructor for singleton
    }

    /**
     * Get the singleton instance of the download service
     */
    public static getInstance(): DownloadService {
        if (!DownloadService.instance) {
            DownloadService.instance = new DownloadService();
        }
        return DownloadService.instance;
    }

    /**
     * Initialize the download service
     */
    public init(): void {
        this.logger.debug('DownloadService: Initialized');
    }

    /**
     * Download artifacts as a ZIP file
     */
    public async downloadArtifactsAsZip(files: ArtifactFile[]): Promise<string> {
        try {
            if (files.length === 0) {
                throw new Error('No artifacts to download');
            }

            // Create ZIP file
            const zipBlob = await ZipCreator.createZip(files);

            // Create a download URL
            const url = URL.createObjectURL(zipBlob);

            // Generate filename
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
            const filename = `claude-artifacts-${timestamp}.zip`;

            // Trigger download
            await this.downloadFile(url, filename);

            // Clean up
            setTimeout(() => URL.revokeObjectURL(url), 60000);

            return filename;
        } catch (error) {
            this.logger.error('DownloadService: Error downloading artifacts as ZIP', error);
            throw error;
        }
    }

    /**
     * Download a single artifact file
     */
    public async downloadSingleArtifact(file: ArtifactFile): Promise<string> {
        try {
            // Create a Blob from the content
            const blob = typeof file.content === 'string'
                ? new Blob([file.content], { type: 'text/plain' })
                : file.content;

            // Create a download URL
            const url = URL.createObjectURL(blob);

            // Trigger download
            await this.downloadFile(url, file.filename);

            // Clean up
            setTimeout(() => URL.revokeObjectURL(url), 60000);

            return file.filename;
        } catch (error) {
            this.logger.error('DownloadService: Error downloading single artifact', error);
            throw error;
        }
    }

    /**
     * Helper to trigger a file download
     */
    private async downloadFile(url: string, filename: string): Promise<void> {
        return new Promise<void>((resolve, reject) => {
            chrome.downloads.download({
                url,
                filename,
                saveAs: false
            }, (downloadId) => {
                if (chrome.runtime.lastError) {
                    reject(chrome.runtime.lastError);
                } else {
                    resolve();
                }
            });
        });
    }
}


================================================================================
FILE: background/services/artifactService.ts
================================================================================

import { Artifact, ArtifactFile } from '../../shared/models/artifact';
import { LoggerService } from '../../shared/services/loggerService';
import { StorageService } from '../../shared/services/storageService';
import { FilenameHelper } from '../../shared/utils/filenameHelper';

/**
 * Service for managing artifacts
 */
export class ArtifactService {
    private static instance: ArtifactService;
    private readonly logger = LoggerService.getInstance();
    private readonly storageService = StorageService.getInstance();

    private constructor() {
        // Private constructor for singleton
    }

    /**
     * Get the singleton instance of the artifact service
     */
    public static getInstance(): ArtifactService {
        if (!ArtifactService.instance) {
            ArtifactService.instance = new ArtifactService();
        }
        return ArtifactService.instance;
    }

    /**
     * Initialize the artifact service
     */
    public init(): void {
        this.logger.debug('ArtifactService: Initialized');
    }

    /**
     * Process artifacts for download
     */
    public async processArtifacts(
        artifacts: Artifact[],
        stitchArtifacts: boolean,
        flatStructure: boolean
    ): Promise<ArtifactFile[]> {
        try {
            // Get settings
            const settings = await this.storageService.getSettings();

            // Stitch artifacts if requested
            let processedArtifacts = artifacts;
            if (stitchArtifacts) {
                // Implementation in artifactExtractor.ts
                // processedArtifacts = ArtifactExtractor.stitchArtifacts(artifacts);
            }

            // Convert artifacts to files
            const files: ArtifactFile[] = [];

            for (const artifact of processedArtifacts) {
                // Generate filename
                const filename = FilenameHelper.getFilename(
                    artifact,
                    settings.includeTimestampInFilename,
                    settings.replaceInvalidChars,
                    settings.maxFilenameLength
                );

                // Generate path for structured storage
                let path = '';
                if (!flatStructure) {
                    path = FilenameHelper.getFolderPath(artifact, 'Claude Conversation');
                }

                // Create file entry
                files.push({
                    filename,
                    content: artifact.content,
                    path,
                    artifact
                });
            }

            return files;
        } catch (error) {
            this.logger.error('ArtifactService: Error processing artifacts', error);
            throw error;
        }
    }

    /**
     * Store an artifact for potential stitching later
     */
    public async storeArtifact(artifact: Artifact): Promise<void> {
        try {
            // Generate a storage key based on title and type
            const key = `artifact-${artifact.title}-${artifact.type}`;

            // Store in local storage
            await this.storageService.saveArtifact(key, artifact);
        } catch (error) {
            this.logger.error('ArtifactService: Error storing artifact', error);
            throw error;
        }
    }

    /**
     * Retrieve stored artifacts
     */
    public async getStoredArtifacts(): Promise<Record<string, Artifact>> {
        try {
            // Implementation would depend on how artifacts are stored
            return {};
        } catch (error) {
            this.logger.error('ArtifactService: Error retrieving stored artifacts', error);
            throw error;
        }
    }
}


================================================================================
FILE: background/services/apiService.ts
================================================================================

import { LoggerService } from '../../shared/services/loggerService';
import { StorageService } from '../../shared/services/storageService';

/**
 * Service for interacting with external APIs
 */
export class ApiService {
    private static instance: ApiService;
    private readonly logger = LoggerService.getInstance();
    private readonly storageService = StorageService.getInstance();
    private apiKey: string = '';

    private constructor() {
        // Private constructor for singleton
    }

    /**
     * Get the singleton instance of the API service
     */
    public static getInstance(): ApiService {
        if (!ApiService.instance) {
            ApiService.instance = new ApiService();
        }
        return ApiService.instance;
    }

    /**
     * Initialize the API service
     */
    public async init(): Promise<void> {
        try {
            // Load settings
            const settings = await this.storageService.getSettings();
            this.apiKey = settings.apiSettings.apiKey;

            this.logger.debug('ApiService: Initialized');
        } catch (error) {
            this.logger.error('ApiService: Initialization error', error);
        }
    }

    /**
     * Send a prompt to Claude API
     */
    public async sendPrompt(prompt: string, options?: any): Promise<any> {
        try {
            // Load settings to get the latest API key
            const settings = await this.storageService.getSettings();
            const apiKey = settings.apiSettings.apiKey;

            if (!apiKey) {
                throw new Error('API key not configured');
            }

            // Prepare request options
            const requestOptions = {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-api-key': apiKey,
                    'anthropic-version': '2023-06-01'
                },
                body: JSON.stringify({
                    model: settings.apiSettings.modelName,
                    max_tokens: settings.apiSettings.maxTokens,
                    temperature: settings.apiSettings.temperature,
                    messages: [
                        {
                            role: 'user',
                            content: prompt
                        }
                    ]
                })
            };

            // Make API request
            const response = await fetch(settings.apiSettings.apiEndpoint, requestOptions);

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`API error (${response.status}): ${errorText}`);
            }

            const data = await response.json();
            return data;
        } catch (error) {
            this.logger.error('ApiService: Error sending prompt', error);
            throw error;
        }
    }

    /**
     * Compile code using remote service
     */
    public async compileCode(code: string, language: string): Promise<any> {
        try {
            // Load settings
            const settings = await this.storageService.getSettings();
            const apiKey = settings.compilerSettings.compilationApiKey;

            if (!settings.compilerSettings.enableCompilation) {
                throw new Error('Code compilation is disabled in settings');
            }

            if (!settings.compilerSettings.useRemoteCompilation) {
                throw new Error('Remote compilation is disabled in settings');
            }

            if (!settings.compilerSettings.supportedLanguages.includes(language)) {
                throw new Error(`Language not supported: ${language}`);
            }

            // Prepare request options
            const requestOptions = {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`
                },
                body: JSON.stringify({
                    language,
                    code,
                    timeout: settings.compilerSettings.executionTimeoutMs
                })
            };

            // Make API request
            const response = await fetch(settings.compilerSettings.remoteCompilationEndpoint, requestOptions);

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Compilation error (${response.status}): ${errorText}`);
            }

            const data = await response.json();
            return {
                output: data.output,
                error: data.error,
                executionTime: data.executionTime
            };
        } catch (error) {
            this.logger.error('ApiService: Error compiling code', error);

            // Return a simulated result for demonstration
            return {
                output: 'Remote compilation unavailable. This is a simulated response.',
                error: error instanceof Error ? error.message : 'Unknown error',
                executionTime: 0
            };
        }
    }
}


================================================================================
FILE: background/services/messageRouter.ts
================================================================================

import { LoggerService } from '../../shared/services/loggerService';
import { ArtifactService } from './artifactService';
import { DownloadService } from './downloadService';
import { ApiService } from './apiService';

/**
 * Router for handling messages from content scripts
 */
export class MessageRouter {
    private static instance: MessageRouter;
    private readonly logger = LoggerService.getInstance();
    private readonly artifactService = ArtifactService.getInstance();
    private readonly downloadService = DownloadService.getInstance();
    private readonly apiService = ApiService.getInstance();

    private constructor() {
        // Private constructor for singleton
    }

    /**
     * Get the singleton instance of the message router
     */
    public static getInstance(): MessageRouter {
        if (!MessageRouter.instance) {
            MessageRouter.instance = new MessageRouter();
        }
        return MessageRouter.instance;
    }

    /**
     * Initialize the message router
     */
    public init(): void {
        // Set up message listener
        chrome.runtime.onMessage.addListener(this.handleMessage.bind(this));

        this.logger.debug('MessageRouter: Initialized');
    }

    /**
     * Handle messages from content scripts
     */
    private handleMessage(
        message: any,
        sender: chrome.runtime.MessageSender,
        sendResponse: (response?: any) => void
    ): boolean {
        if (!message || !message.action) {
            sendResponse({ success: false, error: 'Invalid message format' });
            return false;
        }

        this.logger.debug('MessageRouter: Received message', message);

        // Process message based on action
        switch (message.action) {
            case 'downloadArtifacts':
                this.handleDownloadArtifacts(message, sendResponse);
                return true; // Keep connection open for async response

            case 'remoteCompile':
                this.handleRemoteCompile(message, sendResponse);
                return true; // Keep connection open for async response

            case 'apiRequest':
                this.handleApiRequest(message, sendResponse);
                return true; // Keep connection open for async response

            default:
                sendResponse({ success: false, error: `Unknown action: ${message.action}` });
                return false;
        }
    }

    /**
     * Handle artifact download request
     */
    private async handleDownloadArtifacts(message: any, sendResponse: (response?: any) => void): Promise<void> {
        try {
            const { artifacts, options } = message;

            if (!artifacts || !Array.isArray(artifacts)) {
                sendResponse({ success: false, error: 'No artifacts provided' });
                return;
            }

            // Process artifacts
            const files = await this.artifactService.processArtifacts(
                artifacts,
                options?.stitchArtifacts || false,
                options?.flatStructure || false
            );

            // Download as ZIP
            const filename = await this.downloadService.downloadArtifactsAsZip(files);

            sendResponse({
                success: true,
                filename,
                count: files.length
            });
        } catch (error) {
            this.logger.error('MessageRouter: Error handling download artifacts', error);
            sendResponse({
                success: false,
                error: error instanceof Error ? error.message : 'Unknown error'
            });
        }
    }

    /**
     * Handle remote code compilation request
     */
    private async handleRemoteCompile(message: any, sendResponse: (response?: any) => void): Promise<void> {
        try {
            const { code, language } = message;

            if (!code) {
                sendResponse({ success: false, error: 'No code provided' });
                return;
            }

            // Use API service to compile code
            const result = await this.apiService.compileCode(code, language);

            sendResponse({
                success: true,
                data: result
            });
        } catch (error) {
            this.logger.error('MessageRouter: Error handling remote compile', error);
            sendResponse({
                success: false,
                error: error instanceof Error ? error.message : 'Unknown error'
            });
        }
    }

    /**
     * Handle Claude API request
     */
    private async handleApiRequest(message: any, sendResponse: (response?: any) => void): Promise<void> {
        try {
            const { prompt, options } = message;

            if (!prompt) {
                sendResponse({ success: false, error: 'No prompt provided' });
                return;
            }

            // Use API service to make Claude API request
            const result = await this.apiService.sendPrompt(prompt, options);

            sendResponse({
                success: true,
                data: result
            });
        } catch (error) {
            this.logger.error('MessageRouter: Error handling API request', error);
            sendResponse({
                success: false,
                error: error instanceof Error ? error.message : 'Unknown error'
            });
        }
    }
}


================================================================================
FILE: options/index.ts
================================================================================



================================================================================
FILE: popup/index.ts
================================================================================



================================================================================
FILE: content/eventHandlers.js
================================================================================

import { sendMessageToBackground } from "./messaging.js";

export function downloadArtifacts() {
    const uuid = window.location.pathname.split("/").pop();
    const structure = document.querySelector(".claude-download-options").value;
    sendMessageToBackground({
        action: "downloadArtifacts",
        uuid,
        useDirectoryStructure: structure === "structured",
    });
}


================================================================================
FILE: content/messaging.js
================================================================================



================================================================================
FILE: content/banner.js
================================================================================

export function createBanner(message, type = "error", timeout = 8000) {
    const banner = document.createElement("article");
    banner.className = type;
    banner.innerHTML = `<p>${message}</p>`;
    document.body.prepend(banner);
    setTimeout(() => {
        banner.classList.add("hide");
        setTimeout(() => banner.remove(), 500);
    }, timeout);
}


================================================================================
FILE: content/index.ts
================================================================================

import { LoggerService } from '../shared/services/loggerService';
import { UiInjector } from './ui/UiInjector';
import { BannerService } from './ui/bannerService';
import { MessageService } from './events/messageService';
import { StorageService } from '../shared/services/storageService';
import { CompilerService } from './editor/compilerService';

/**
 * Main entry point for the content script
 */
class ContentScript {
    private readonly logger = LoggerService.getInstance();
    private readonly uiInjector = UiInjector.getInstance();
    private readonly bannerService = BannerService.getInstance();
    private readonly messageService = MessageService.getInstance();
    private readonly storageService = StorageService.getInstance();
    private readonly compilerService = CompilerService.getInstance();

    constructor() {
        this.init().catch(error => {
            console.error('ContentScript: Initialization error', error);
        });
    }

    /**
     * Initialize the content script
     */
    private async init(): Promise<void> {
        try {
            this.logger.info('ContentScript: Initializing');

            // Load settings
            const settings = await this.storageService.getSettings();

            // Set notification duration from settings
            this.bannerService.setNotificationDuration(
                settings.uiSettings.notificationDurationMs
            );

            // Register message handlers
            this.registerMessageHandlers();

            // Initialize UI injector
            await this.uiInjector.init();

            // Notification on successful initialization
            if (settings.uiSettings.showNotifications) {
                this.bannerService.showSuccess('Claude Artifacts extension initialized', 2000);
            }

            this.logger.info('ContentScript: Initialization complete');
        } catch (error) {
            this.logger.error('ContentScript: Initialization failed', error);
        }
    }

    /**
     * Register handlers for background script messages
     */
    private registerMessageHandlers(): void {
        // Handler for showing settings UI
        this.messageService.registerHandler('showSettings', async () => {
            // Implemented in settings UI module
            return true;
        });

        // Handler for showing notifications
        this.messageService.registerHandler('showNotification', async (message) => {
            const { type, text, duration } = message;

            switch (type) {
                case 'success':
                    this.bannerService.showSuccess(text, duration);
                    break;
                case 'error':
                    this.bannerService.showError(text, duration);
                    break;
                case 'info':
                    this.bannerService.showInfo(text, duration);
                    break;
                case 'warning':
                    this.bannerService.showWarning(text, duration);
                    break;
                default:
                    this.bannerService.showInfo(text, duration);
            }

            return true;
        });
    }
}

// Initialize content script
new ContentScript();


================================================================================
FILE: content/content.js
================================================================================

import "./uiInjector.js";
import "./eventHandlers.js";
import "./messaging.js";
import "./banner.js";

console.log("Claude Downloader Content Script Loaded.");


================================================================================
FILE: content/uiInjector.js
================================================================================

import { downloadArtifacts } from "./eventHandlers.js";

function injectUI() {
    const buttonContainer = document.querySelector(".flex.min-w-0.items-center.max-md\\:text-sm");
    if (!buttonContainer || buttonContainer.querySelector(".claude-download-button")) return;

    const container = document.createElement("div");
    container.className = "claude-download-container ml-1 flex items-center";
    container.innerHTML = `
    <select class="claude-download-options rounded-md bg-gray-100 py-1 px-2 text-sm">
      <option value="flat">Flat structure</option>
      <option value="structured">Inferred structure</option>
    </select>
    <button class="claude-download-button ml-1 rounded-md bg-gray-100 py-1 px-3 text-sm">
      <i class="fa fa-download mr-2"></i>Download artifacts
    </button>
  `;
    buttonContainer.appendChild(container);

    container.querySelector(".claude-download-button").onclick = downloadArtifacts;
}

setInterval(injectUI, 1500);


================================================================================
FILE: content/ui/settingsManager.ts
================================================================================

import { StorageService } from '@/background/storageService';
import {LoggerService} from '@/shared/services/loggerService';

export class SettingsManager {
    private static instance: SettingsManager;
    private readonly logger: LoggerService;
    private readonly storageService: StorageService;
    private settings: ISettings = {
        enabled: true
    };

    /**
     * Private constructor to enforce singleton pattern
     */
    private constructor() {
        this.logger = LoggerService.getInstance();
        this.storageService = StorageService.getInstance();
    }

    /**
     * Get the singleton instance
     */
    public static getInstance(): SettingsManager {
        if (!SettingsManager.instance) {
            SettingsManager.instance = new SettingsManager();
        }
        return SettingsManager.instance;
    }

    /**
     * Initialize the settings manager
     */
    public async initialize(): Promise<void> {
        await this.loadSettings();
        this.logger.info('SettingsManager initialized');
    }

    /**
     * Load settings from storage
     */
    private async loadSettings(): Promise<void> {
        this.settings = await this.storageService.get<ISettings>('settings') || this.settings;
    }

    /**
     * Save settings to storage
     */
    private async saveSettings(): Promise<void> {
        await this.storageService.set<ISettings>('settings', this.settings);

        // Notify listeners of the updated settings
        this.notifyListeners();
    }

    /**
     * Get the current settings
     */
    public getSettings(): ISettings {
        return this.settings;
    }

    /**
     * Update the settings
     * @param settings New settings
     */
    public async updateSettings(settings: ISettings): Promise<void> {
        this.settings = settings;
        await this.saveSettings();
    }

    // Listener functionality
    private listeners: Set<SettingsListener> = new Set();

    /**
     * Add a listener for settings changes
     * @param listener The listener to add
     */
    public addListener(listener: SettingsListener): void {
        this.listeners.add(listener);
    }

    /**
     * Remove a listener for settings changes
     * @param listener The listener to remove
     */
    public removeListener(listener: SettingsListener): void {
        this.listeners.delete(listener);
    }

    /**
     * Notify all listeners of settings changes
     */
    private notifyListeners(): void {
        this.listeners.forEach(listener => {
            try {
                listener(this.settings);
            } catch (error) {
                this.logger.error('Error in settings listener:', error);
            }
        });
    }

    /**
     * Clean up resources
     */
    public destroy(): void {
        this.listeners.clear();
        this.logger.info('SettingsManager destroyed');
    }
}


================================================================================
FILE: content/ui/uiInjector.ts
================================================================================

import { EditorManager } from '../editor/editorManager';
import { MessageService } from '../events/messageService';
import { BannerService } from './bannerService';
import { StorageService } from '../../shared/services/storageService';
import { LoggerService } from '../../shared/services/loggerService';
import { ArtifactSettings, UIElements } from '../../shared/models/settings';

/**
 * UiInjector is responsible for injecting UI elements into the Claude interface
 * and managing their lifecycle and event handling.
 */
export class UiInjector {
    private static instance: UiInjector;
    private readonly logger = LoggerService.getInstance();
    private readonly messageService = MessageService.getInstance();
    private readonly bannerService = BannerService.getInstance();
    private readonly storageService = StorageService.getInstance();
    private readonly editorManager = EditorManager.getInstance();

    private observer: MutationObserver | null = null;
    private downloadButton: HTMLButtonElement | null = null;
    private settingsButton: HTMLButtonElement | null = null;
    private headerContainer: HTMLElement | null = null;
    private isInitialized = false;
    private settings: ArtifactSettings | null = null;

    // UI Element selectors
    private readonly SELECTORS = {
        CLAUDE_HEADER: '.claude-header',
        CLAUDE_CONTROLS: '.claude-controls',
        ARTIFACT_CONTAINER: '.antml-artifact-container',
        ARTIFACT_TITLE: '.antml-artifact-title',
        MESSAGE_CONTAINER: '.prose',
        CONVERSATION_CONTAINER: '.conversation-container'
    };

    private constructor() {
        this.logger.debug('UiInjector: Initializing');
    }

    public static getInstance(): UiInjector {
        if (!UiInjector.instance) {
            UiInjector.instance = new UiInjector();
        }
        return UiInjector.instance;
    }

    /**
     * Initialize the UI injector by loading settings and starting the observer
     */
    public async init(): Promise<void> {
        if (this.isInitialized) {
            return;
        }

        try {
            this.settings = await this.storageService.getSettings();
            this.startObserver();
            this.injectStylesheet();
            this.isInitialized = true;
            this.logger.info('UiInjector: Initialized successfully');
        } catch (error) {
            this.logger.error('UiInjector: Failed to initialize', error);
            this.bannerService.showError('Failed to initialize UI components');
        }
    }

    /**
     * Clean up resources when the injector is no longer needed
     */
    public destroy(): void {
        if (this.observer) {
            this.observer.disconnect();
            this.observer = null;
        }
        this.removeInjectedElements();
        this.isInitialized = false;
        this.logger.debug('UiInjector: Destroyed');
    }

    /**
     * Start a mutation observer to watch for changes in the DOM
     * that would indicate we need to inject our UI elements
     */
    private startObserver(): void {
        if (this.observer) {
            this.observer.disconnect();
        }

        this.observer = new MutationObserver(this.handleDomMutations.bind(this));
        this.observer.observe(document.body, {
            childList: true,
            subtree: true
        });

        // Also check immediately in case the elements are already present
        this.checkAndInjectElements();
    }

    /**
     * Handle DOM mutations by checking if we need to inject elements
     */
    private handleDomMutations(mutations: MutationRecord[]): void {
        // Only process if we have new nodes added
        const hasNewNodes = mutations.some(mutation =>
            mutation.type === 'childList' && mutation.addedNodes.length > 0);

        if (hasNewNodes) {
            this.checkAndInjectElements();
        }
    }

    /**
     * Check if relevant Claude elements exist and inject our custom elements if needed
     */
    private checkAndInjectElements(): void {
        // Try to find the Claude header if we don't already have it
        if (!this.headerContainer) {
            this.headerContainer = document.querySelector(this.SELECTORS.CLAUDE_HEADER);
        }

        // If we found the header, inject our buttons
        if (this.headerContainer && !this.downloadButton) {
            this.injectButtons();
        }

        // Process any artifacts that might be on the page
        this.processExistingArtifacts();
    }

    /**
     * Inject the download and settings buttons into the Claude header
     */
    private injectButtons(): void {
        const controlsContainer = this.headerContainer?.querySelector(this.SELECTORS.CLAUDE_CONTROLS);

        if (!controlsContainer) {
            this.logger.warn('UiInjector: Could not find controls container');
            return;
        }

        // Create container for our buttons
        const buttonContainer = document.createElement('div');
        buttonContainer.className = 'claude-artifact-buttons';
        buttonContainer.style.display = 'flex';
        buttonContainer.style.gap = '8px';
        buttonContainer.style.marginLeft = '8px';

        // Create download button
        this.downloadButton = this.createDownloadButton();
        buttonContainer.appendChild(this.downloadButton);

        // Create settings button
        this.settingsButton = this.createSettingsButton();
        buttonContainer.appendChild(this.settingsButton);

        // Add buttons to the controls container
        controlsContainer.appendChild(buttonContainer);
        this.logger.info('UiInjector: Buttons injected');
    }

    /**
     * Create the download button with appropriate styling and event handling
     */
    private createDownloadButton(): HTMLButtonElement {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'claude-download-button';
        button.title = 'Download artifacts from this conversation';
        button.innerHTML = `
      <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
        <polyline points="7 10 12 15 17 10"></polyline>
        <line x1="12" y1="15" x2="12" y2="3"></line>
      </svg>
      <span>Download artifacts</span>
    `;

        // Add styling
        Object.assign(button.style, {
            display: 'flex',
            alignItems: 'center',
            gap: '6px',
            padding: '6px 12px',
            borderRadius: '4px',
            border: '1px solid #e2e8f0',
            backgroundColor: '#f8fafc',
            color: '#334155',
            cursor: 'pointer',
            fontSize: '14px',
            fontWeight: '500',
            transition: 'all 0.2s ease'
        });

        // Add event listener
        button.addEventListener('click', this.handleDownloadClick.bind(this));

        // Add hover effect
        button.addEventListener('mouseover', () => {
            Object.assign(button.style, {
                backgroundColor: '#f1f5f9',
                borderColor: '#cbd5e1'
            });
        });

        button.addEventListener('mouseout', () => {
            Object.assign(button.style, {
                backgroundColor: '#f8fafc',
                borderColor: '#e2e8f0'
            });
        });

        return button;
    }

    /**
     * Create the settings button with appropriate styling and event handling
     */
    private createSettingsButton(): HTMLButtonElement {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'claude-settings-button';
        button.title = 'Artifact download settings';
        button.innerHTML = `
      <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <circle cx="12" cy="12" r="3"></circle>
        <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
      </svg>
    `;

        // Add styling
        Object.assign(button.style, {
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            padding: '6px',
            borderRadius: '4px',
            border: '1px solid #e2e8f0',
            backgroundColor: '#f8fafc',
            color: '#334155',
            cursor: 'pointer',
            transition: 'all 0.2s ease'
        });

        // Add event listener
        button.addEventListener('click', this.handleSettingsClick.bind(this));

        // Add hover effect
        button.addEventListener('mouseover', () => {
            Object.assign(button.style, {
                backgroundColor: '#f1f5f9',
                borderColor: '#cbd5e1'
            });
        });

        button.addEventListener('mouseout', () => {
            Object.assign(button.style, {
                backgroundColor: '#f8fafc',
                borderColor: '#e2e8f0'
            });
        });

        return button;
    }

    /**
     * Process existing artifacts on the page to add edit buttons
     */
    private processExistingArtifacts(): void {
        const artifactContainers = document.querySelectorAll(this.SELECTORS.ARTIFACT_CONTAINER);

        artifactContainers.forEach(container => {
            // Skip already processed containers
            if (container.querySelector('.artifact-edit-button')) {
                return;
            }

            this.addArtifactControls(container as HTMLElement);
        });
    }

    /**
     * Add controls to an artifact container (edit, run buttons)
     */
    private addArtifactControls(container: HTMLElement): void {
        // Find the artifact title element to place our controls next to it
        const titleElement = container.querySelector(this.SELECTORS.ARTIFACT_TITLE);
        if (!titleElement) {
            return;
        }

        // Create controls container
        const controlsContainer = document.createElement('div');
        controlsContainer.className = 'artifact-controls';
        Object.assign(controlsContainer.style, {
            display: 'flex',
            gap: '8px',
            marginLeft: 'auto'
        });

        // Create edit button
        const editButton = this.createEditButton();
        controlsContainer.appendChild(editButton);

        // Create run button for code artifacts
        const isCodeArtifact = container.classList.contains('code-artifact') ||
            container.querySelector('pre code') !== null;

        if (isCodeArtifact) {
            const runButton = this.createRunButton();
            controlsContainer.appendChild(runButton);
        }

        // Add controls to the title element
        Object.assign(titleElement.style, {
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'space-between'
        });

        titleElement.appendChild(controlsContainer);

        // Store artifact data for later use
        this.storeArtifactData(container);
    }

    /**
     * Create an edit button for an artifact
     */
    private createEditButton(): HTMLButtonElement {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'artifact-edit-button';
        button.title = 'Edit this artifact';
        button.innerHTML = `
      <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
        <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
      </svg>
      <span>Edit</span>
    `;

        // Add styling
        Object.assign(button.style, {
            display: 'flex',
            alignItems: 'center',
            gap: '4px',
            padding: '4px 8px',
            borderRadius: '4px',
            border: '1px solid #e2e8f0',
            backgroundColor: '#f8fafc',
            color: '#334155',
            cursor: 'pointer',
            fontSize: '12px',
            fontWeight: '500'
        });

        // Add event listener
        button.addEventListener('click', (event) => {
            const artifactContainer = (event.target as HTMLElement)
                .closest(this.SELECTORS.ARTIFACT_CONTAINER) as HTMLElement;

            if (artifactContainer) {
                this.handleArtifactEdit(artifactContainer, button);
            }
        });

        return button;
    }

    /**
     * Create a run button for code artifacts
     */
    private createRunButton(): HTMLButtonElement {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'artifact-run-button';
        button.title = 'Run this code';
        button.innerHTML = `
      <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <polygon points="5 3 19 12 5 21 5 3"></polygon>
      </svg>
      <span>Run</span>
    `;

        // Add styling
        Object.assign(button.style, {
            display: 'flex',
            alignItems: 'center',
            gap: '4px',
            padding: '4px 8px',
            borderRadius: '4px',
            border: '1px solid #d1fae5',
            backgroundColor: '#ecfdf5',
            color: '#065f46',
            cursor: 'pointer',
            fontSize: '12px',
            fontWeight: '500'
        });

        // Add event listener
        button.addEventListener('click', (event) => {
            const artifactContainer = (event.target as HTMLElement)
                .closest(this.SELECTORS.ARTIFACT_CONTAINER) as HTMLElement;

            if (artifactContainer) {
                this.handleArtifactRun(artifactContainer);
            }
        });

        return button;
    }

    /**
     * Store artifact data for later reference
     */
    private storeArtifactData(container: HTMLElement): void {
        // Extract artifact metadata
        const titleElement = container.querySelector(this.SELECTORS.ARTIFACT_TITLE) as HTMLElement;
        const title = titleElement?.textContent?.trim() || 'Untitled Artifact';

        // Determine artifact type
        let artifactType = 'text';
        if (container.classList.contains('code-artifact') || container.querySelector('pre code')) {
            artifactType = 'code';
        } else if (container.querySelector('svg')) {
            artifactType = 'svg';
        } else if (container.querySelector('table')) {
            artifactType = 'table';
        }

        // Get language for code artifacts
        let language = '';
        const codeElement = container.querySelector('pre code');
        if (codeElement) {
            const classNames = Array.from(codeElement.classList);
            const langClass = classNames.find(cls => cls.startsWith('language-'));
            if (langClass) {
                language = langClass.replace('language-', '');
            }
        }

        // Store the data as a data attribute on the container
        container.dataset.artifactMetadata = JSON.stringify({
            title,
            type: artifactType,
            language,
            timestamp: new Date().toISOString()
        });
    }

    /**
     * Handle the download button click
     */
    private async handleDownloadClick(): Promise<void> {
        try {
            this.downloadButton?.setAttribute('disabled', 'true');
            this.downloadButton?.classList.add('loading');

            // Update button text
            const originalText = this.downloadButton?.innerHTML || '';
            this.downloadButton!.innerHTML = `
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="animate-spin">
          <circle cx="12" cy="12" r="10"></circle>
          <path d="M16 12a4 4 0 1 1-8 0 4 4 0 0 1 8 0z"></path>
        </svg>
        <span>Processing...</span>
      `;

            // Request artifact download from background script
            const result = await this.messageService.sendMessage({
                action: 'downloadArtifacts',
                options: {
                    stitchArtifacts: this.settings?.stitchArtifacts || false,
                    flatStructure: this.settings?.flatFileStructure || false
                }
            });

            if (result.success) {
                this.bannerService.showSuccess('Artifacts downloaded successfully');
            } else {
                this.bannerService.showError(result.error || 'Failed to download artifacts');
            }
        } catch (error) {
            this.logger.error('UiInjector: Download error', error);
            this.bannerService.showError('Failed to download artifacts');
        } finally {
            // Restore button state
            if (this.downloadButton) {
                this.downloadButton.removeAttribute('disabled');
                this.downloadButton.classList.remove('loading');
                this.downloadButton.innerHTML = originalText || `
          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
            <polyline points="7 10 12 15 17 10"></polyline>
            <line x1="12" y1="15" x2="12" y2="3"></line>
          </svg>
          <span>Download artifacts</span>
        `;
            }
        }
    }

    /**
     * Handle settings button click
     */
    private handleSettingsClick(): void {
        // Send message to show settings
        this.messageService.sendMessage({
            action: 'showSettings'
        });
    }

    /**
     * Handle artifact edit button click
     */
    private async handleArtifactEdit(container: HTMLElement, button: HTMLButtonElement): Promise<void> {
        try {
            const isEditMode = container.classList.contains('editing-mode');

            if (isEditMode) {
                // Save changes and exit edit mode
                await this.editorManager.saveChanges(container);
                button.innerHTML = `
          <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
            <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
          </svg>
          <span>Edit</span>
        `;
            } else {
                // Enter edit mode
                await this.editorManager.createEditor(container);
                button.innerHTML = `
          <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
            <polyline points="17 21 17 13 7 13 7 21"></polyline>
            <polyline points="7 3 7 8 15 8"></polyline>
          </svg>
          <span>Save</span>
        `;
            }
        } catch (error) {
            this.logger.error('UiInjector: Edit error', error);
            this.bannerService.showError('Failed to edit artifact');
        }
    }

    /**
     * Handle artifact run button click
     */
    private async handleArtifactRun(container: HTMLElement): Promise<void> {
        try {
            const metadata = this.extractArtifactMetadata(container);

            if (!metadata || metadata.type !== 'code') {
                this.bannerService.showError('Can only run code artifacts');
                return;
            }

            // Get the code content
            let code: string;

            if (container.classList.contains('editing-mode')) {
                // Get code from Monaco editor
                code = this.editorManager.getEditorContent(container) || '';
            } else {
                // Get code from pre element
                const codeElement = container.querySelector('pre code');
                code = codeElement?.textContent || '';
            }

            if (!code.trim()) {
                this.bannerService.showError('No code to run');
                return;
            }

            // Show compiling message
            this.bannerService.showInfo('Compiling code...');

            // Send code to compiler service
            const result = await this.messageService.sendMessage({
                action: 'compileAndRun',
                code,
                language: metadata.language || 'javascript'
            });

            if (result.success) {
                // Create or update output container
                this.displayCompilationResult(container, result.data);
            } else {
                this.bannerService.showError(result.error || 'Failed to run code');
            }
        } catch (error) {
            this.logger.error('UiInjector: Run error', error);
            this.bannerService.showError('Failed to run code');
        }
    }

    /**
     * Display compilation results
     */
    private displayCompilationResult(container: HTMLElement, result: any): void {
        // Check if output container already exists
        let outputContainer = container.querySelector('.compilation-output');

        if (!outputContainer) {
            // Create new output container
            outputContainer = document.createElement('div');
            outputContainer.className = 'compilation-output';
            Object.assign(outputContainer.style, {
                marginTop: '12px',
                padding: '12px',
                backgroundColor: '#f8fafc',
                borderRadius: '4px',
                border: '1px solid #e2e8f0',
                maxHeight: '300px',
                overflow: 'auto',
                fontSize: '14px',
                fontFamily: 'monospace'
            });

            container.appendChild(outputContainer);
        }

        // Clear previous content
        outputContainer.innerHTML = '';

        // Add header
        const header = document.createElement('div');
        header.style.fontWeight = 'bold';
        header.style.marginBottom = '8px';
        header.style.display = 'flex';
        header.style.justifyContent = 'space-between';
        header.innerHTML = `
      <span>Execution Results</span>
      <span class="close-output" style="cursor:pointer"></span>
    `;
        outputContainer.appendChild(header);

        // Add close button handler
        header.querySelector('.close-output')?.addEventListener('click', () => {
            outputContainer?.remove();
        });

        // Add content based on result type
        if (result.error) {
            const errorDiv = document.createElement('div');
            errorDiv.style.color = '#ef4444';
            errorDiv.textContent = result.error;
            outputContainer.appendChild(errorDiv);
        } else {
            // Create content based on result type
            if (typeof result.output === 'string') {
                const outputPre = document.createElement('pre');
                outputPre.style.margin = '0';
                outputPre.style.whiteSpace = 'pre-wrap';
                outputPre.textContent = result.output;
                outputContainer.appendChild(outputPre);
            } else {
                try {
                    const outputPre = document.createElement('pre');
                    outputPre.style.margin = '0';
                    outputPre.style.whiteSpace = 'pre-wrap';
                    outputPre.textContent = JSON.stringify(result.output, null, 2);
                    outputContainer.appendChild(outputPre);
                } catch (e) {
                    const outputDiv = document.createElement('div');
                    outputDiv.textContent = 'Complex output (cannot display)';
                    outputContainer.appendChild(outputDiv);
                }
            }
        }
    }

    /**
     * Extract artifact metadata from data attribute
     */
    private extractArtifactMetadata(container: HTMLElement): any {
        try {
            const metadataStr = container.dataset.artifactMetadata;
            if (metadataStr) {
                return JSON.parse(metadataStr);
            }
        } catch (error) {
            this.logger.error('UiInjector: Failed to parse artifact metadata', error);
        }
        return null;
    }

    /**
     * Inject the stylesheet for custom UI elements
     */
    private injectStylesheet(): void {
        const style = document.createElement('style');
        style.id = 'claude-artifacts-styles';
        style.textContent = `
      .claude-artifact-buttons button:focus-visible {
        outline: 2px solid #3b82f6;
        outline-offset: 2px;
      }
      
      .artifact-controls button:focus-visible {
        outline: 2px solid #3b82f6;
        outline-offset: 2px;
      }
      
      .editing-mode {
        position: relative;
      }
      
      .monaco-editor {
        min-height: 100px;
        border-radius: 4px;
        overflow: hidden;
      }
      
      .compilation-output::-webkit-scrollbar {
        width: 8px;
        height: 8px;
      }
      
      .compilation-output::-webkit-scrollbar-track {
        background: #f1f5f9;
      }
      
      .compilation-output::-webkit-scrollbar-thumb {
        background-color: #cbd5e1;
        border-radius: 4px;
      }
      
      @keyframes fadeIn {
        from { opacity: 0; transform: translateY(-10px); }
        to { opacity: 1; transform: translateY(0); }
      }
      
      .artifact-notification {
        animation: fadeIn 0.3s ease-out forwards;
      }
    `;

        document.head.appendChild(style);
    }

    /**
     * Remove injected UI elements
     */
    private removeInjectedElements(): void {
        // Remove buttons
        document.querySelector('.claude-artifact-buttons')?.remove();

        // Remove styles
        document.getElementById('claude-artifacts-styles')?.remove();

        // Restore artifact containers
        document.querySelectorAll('.editing-mode').forEach(editor => {
            this.editorManager.removeEditor(editor as HTMLElement);
        });

        // Remove compilation outputs
        document.querySelectorAll('.compilation-output').forEach(output => {
            output.remove();
        });

        // Reset state
        this.downloadButton = null;
        this.settingsButton = null;
        this.headerContainer = null;
    }
}


================================================================================
FILE: content/ui/settingsUI.ts
================================================================================

import { LoggerService } from '../../shared/services/loggerService';
import { StorageService } from '../../shared/services/storageService';
import { MessageService } from '../events/messageService';
import { BannerService } from './bannerService';
import { ArtifactSettings, DEFAULT_SETTINGS } from '../../shared/models/settings';

/**
 * UI for managing extension settings
 */
export class SettingsUI {
    private static instance: SettingsUI;
    private readonly logger = LoggerService.getInstance();
    private readonly storageService = StorageService.getInstance();
    private readonly messageService = MessageService.getInstance();
    private readonly bannerService = BannerService.getInstance();

    private settingsPanel: HTMLElement | null = null;
    private isVisible = false;
    private settings: ArtifactSettings | null = null;

    private constructor() {
        // Register message handler for showing settings
        this.messageService.registerHandler('showSettings', this.handleShowSettings.bind(this));
    }

    /**
     * Get the singleton instance of the settings UI
     */
    public static getInstance(): SettingsUI {
        if (!SettingsUI.instance) {
            SettingsUI.instance = new SettingsUI();
        }
        return SettingsUI.instance;
    }

    /**
     * Show the settings panel
     */
    public async show(): Promise<void> {
        if (this.isVisible) return;

        try {
            // Load settings
            this.settings = await this.storageService.getSettings();

            // Create panel if it doesn't exist
            if (!this.settingsPanel) {
                this.createSettingsPanel();
            }

            // Show the panel
            if (this.settingsPanel) {
                document.body.appendChild(this.settingsPanel);

                // Add animation
                setTimeout(() => {
                    if (this.settingsPanel) {
                        this.settingsPanel.style.opacity = '1';
                        this.settingsPanel.style.transform = 'translateY(0)';
                    }
                }, 10);

                this.isVisible = true;
            }
        } catch (error) {
            this.logger.error('SettingsUI: Error showing settings', error);
            this.bannerService.showError('Failed to load settings');
        }
    }

    /**
     * Hide the settings panel
     */
    public hide(): void {
        if (!this.isVisible || !this.settingsPanel) return;

        // Add animation
        this.settingsPanel.style.opacity = '0';
        this.settingsPanel.style.transform = 'translateY(20px)';

        // Remove after animation
        setTimeout(() => {
            if (this.settingsPanel && this.settingsPanel.parentNode) {
                this.settingsPanel.parentNode.removeChild(this.settingsPanel);
            }
            this.isVisible = false;
        }, 300);
    }

    /**
     * Create the settings panel UI
     */
    private createSettingsPanel(): void {
        // Create panel container
        const panel = document.createElement('div');
        panel.className = 'claude-artifacts-settings';
        panel.setAttribute('role', 'dialog');
        panel.setAttribute('aria-labelledby', 'settings-title');

        // Base styling
        Object.assign(panel.style, {
            position: 'fixed',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%) translateY(20px)',
            maxWidth: '600px',
            width: '90%',
            maxHeight: '80vh',
            backgroundColor: '#ffffff',
            borderRadius: '8px',
            boxShadow: '0 4px 20px rgba(0, 0, 0, 0.15)',
            zIndex: '10000',
            overflow: 'hidden',
            display: 'flex',
            flexDirection: 'column',
            opacity: '0',
            transition: 'opacity 0.3s ease, transform 0.3s ease'
        });

        // Add content
        panel.innerHTML = `
      <div style="display: flex; align-items: center; justify-content: space-between; padding: 16px 20px; border-bottom: 1px solid #e2e8f0;">
        <h2 id="settings-title" style="margin: 0; font-size: 18px; font-weight: 600; color: #1e293b;">Claude Artifacts Settings</h2>
        <button id="close-settings" style="background: none; border: none; cursor: pointer; padding: 4px;">
          <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
          </svg>
        </button>
      </div>
      
      <div style="flex: 1; overflow-y: auto; padding: 20px;">
        <div style="display: flex; flex-direction: column; gap: 24px;">
          <!-- Artifact Download Settings -->
          <section>
            <h3 style="margin: 0 0 12px 0; font-size: 16px; font-weight: 600; color: #334155;">Artifact Download</h3>
            <div style="display: flex; flex-direction: column; gap: 12px;">
              <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                <input type="checkbox" id="stitch-artifacts" ${this.settings?.stitchArtifacts ? 'checked' : ''}>
                <span>Automatically stitch related artifacts</span>
              </label>
              
              <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                <input type="checkbox" id="flat-structure" ${this.settings?.flatFileStructure ? 'checked' : ''}>
                <span>Use flat file structure (no folders)</span>
              </label>
              
              <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                <input type="checkbox" id="include-timestamp" ${this.settings?.includeTimestampInFilename ? 'checked' : ''}>
                <span>Include timestamp in filenames</span>
              </label>
            </div>
          </section>
          
          <!-- Editor Settings -->
          <section>
            <h3 style="margin: 0 0 12px 0; font-size: 16px; font-weight: 600; color: #334155;">Editor</h3>
            <div style="display: flex; flex-direction: column; gap: 12px;">
              <div>
                <label for="editor-theme" style="display: block; margin-bottom: 4px;">Theme</label>
                <select id="editor-theme" style="width: 100%; padding: 8px; border: 1px solid #e2e8f0; border-radius: 4px;">
                  <option value="vs" ${this.settings?.editorSettings.theme === 'vs' ? 'selected' : ''}>Light</option>
                  <option value="vs-dark" ${this.settings?.editorSettings.theme === 'vs-dark' ? 'selected' : ''}>Dark</option>
                  <option value="hc-black" ${this.settings?.editorSettings.theme === 'hc-black' ? 'selected' : ''}>High Contrast</option>
                </select>
              </div>
              
              <div>
                <label for="font-size" style="display: block; margin-bottom: 4px;">Font Size</label>
                <input type="number" id="font-size" min="10" max="24" value="${this.settings?.editorSettings.fontSize || 14}" style="width: 100%; padding: 8px; border: 1px solid #e2e8f0; border-radius: 4px;">
              </div>
              
              <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                <input type="checkbox" id="line-numbers" ${this.settings?.editorSettings.lineNumbers === 'on' ? 'checked' : ''}>
                <span>Show line numbers</span>
              </label>
              
              <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                <input type="checkbox" id="word-wrap" ${this.settings?.editorSettings.wordWrap === 'on' ? 'checked' : ''}>
                <span>Word wrap</span>
              </label>
              
              <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                <input type="checkbox" id="minimap" ${this.settings?.editorSettings.minimap ? 'checked' : ''}>
                <span>Show minimap</span>
              </label>
            </div>
          </section>
          
          <!-- API Settings -->
          <section>
            <h3 style="margin: 0 0 12px 0; font-size: 16px; font-weight: 600; color: #334155;">API Settings</h3>
            <div style="display: flex; flex-direction: column; gap: 12px;">
              <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                <input type="checkbox" id="enable-api" ${this.settings?.apiSettings.enableApiContinuation ? 'checked' : ''}>
                <span>Enable API continuation when rate limited</span>
              </label>
              
              <div>
                <label for="api-key" style="display: block; margin-bottom: 4px;">Claude API Key</label>
                <input type="password" id="api-key" value="${this.settings?.apiSettings.apiKey || ''}" placeholder="sk-..." style="width: 100%; padding: 8px; border: 1px solid #e2e8f0; border-radius: 4px;">
              </div>
              
              <div>
                <label for="model-name" style="display: block; margin-bottom: 4px;">Model</label>
                <select id="model-name" style="width: 100%; padding: 8px; border: 1px solid #e2e8f0; border-radius: 4px;">
                  <option value="claude-3-haiku-20240307" ${this.settings?.apiSettings.modelName === 'claude-3-haiku-20240307' ? 'selected' : ''}>Claude 3 Haiku</option>
                  <option value="claude-3-sonnet-20240229" ${this.settings?.apiSettings.modelName === 'claude-3-sonnet-20240229' ? 'selected' : ''}>Claude 3 Sonnet</option>
                  <option value="claude-3-opus-20240229" ${this.settings?.apiSettings.modelName === 'claude-3-opus-20240229' ? 'selected' : ''}>Claude 3 Opus</option>
                </select>
              </div>
            </div>
          </section>
          
          <!-- Reset Settings -->
          <section>
            <button id="reset-settings" style="padding: 8px 16px; background-color: #f1f5f9; border: 1px solid #cbd5e1; border-radius: 4px; cursor: pointer; color: #334155; font-weight: 500;">
              Reset to Defaults
            </button>
          </section>
        </div>
      </div>
      
      <div style="padding: 16px 20px; border-top: 1px solid #e2e8f0; display: flex; justify-content: flex-end; gap: 12px;">
        <button id="cancel-settings" style="padding: 8px 16px; background-color: #f1f5f9; border: 1px solid #cbd5e1; border-radius: 4px; cursor: pointer; color: #334155; font-weight: 500;">
          Cancel
        </button>
        <button id="save-settings" style="padding: 8px 16px; background-color: #2563eb; border: none; border-radius: 4px; cursor: pointer; color: white; font-weight: 500;">
          Save Changes
        </button>
      </div>
    `;

        // Add backdrop
        const backdrop = document.createElement('div');
        backdrop.style.position = 'fixed';
        backdrop.style.top = '0';
        backdrop.style.left = '0';
        backdrop.style.width = '100%';
        backdrop.style.height = '100%';
        backdrop.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
        backdrop.style.zIndex = '9999';
        backdrop.style.opacity = '0';
        backdrop.style.transition = 'opacity 0.3s ease';

        // Add handlers
        setTimeout(() => {
            backdrop.style.opacity = '1';
        }, 10);

        backdrop.addEventListener('click', () => {
            this.hide();
        });

        // Add event listeners
        panel.querySelector('#close-settings')?.addEventListener('click', () => {
            this.hide();
        });

        panel.querySelector('#cancel-settings')?.addEventListener('click', () => {
            this.hide();
        });

        panel.querySelector('#save-settings')?.addEventListener('click', () => {
            this.saveSettings();
        });

        panel.querySelector('#reset-settings')?.addEventListener('click', () => {
            this.resetSettings();
        });

        // Prevent clicks inside panel from closing
        panel.addEventListener('click', (e) => {
            e.stopPropagation();
        });

        // Store references
        this.settingsPanel = panel;

        // Add panel and backdrop to the DOM
        document.body.appendChild(backdrop);
    }

    /**
     * Save settings changes
     */
    private async saveSettings(): Promise<void> {
        if (!this.settings) return;

        try {
            // Get values from form elements
            const stitchArtifacts = (document.getElementById('stitch-artifacts') as HTMLInputElement)?.checked ?? this.settings.stitchArtifacts;
            const flatStructure = (document.getElementById('flat-structure') as HTMLInputElement)?.checked ?? this.settings.flatFileStructure;
            const includeTimestamp = (document.getElementById('include-timestamp') as HTMLInputElement)?.checked ?? this.settings.includeTimestampInFilename;

            // Editor settings
            const editorTheme = (document.getElementById('editor-theme') as HTMLSelectElement)?.value as 'vs' | 'vs-dark' | 'hc-black';
            const fontSize = parseInt((document.getElementById('font-size') as HTMLInputElement)?.value || '14');
            const lineNumbers = (document.getElementById('line-numbers') as HTMLInputElement)?.checked ? 'on' : 'off';
            const wordWrap = (document.getElementById('word-wrap') as HTMLInputElement)?.checked ? 'on' : 'off';
            const minimap = (document.getElementById('minimap') as HTMLInputElement)?.checked ?? this.settings.editorSettings.minimap;

            // API settings
            const enableApi = (document.getElementById('enable-api') as HTMLInputElement)?.checked ?? this.settings.apiSettings.enableApiContinuation;
            const apiKey = (document.getElementById('api-key') as HTMLInputElement)?.value || '';
            const modelName = (document.getElementById('model-name') as HTMLSelectElement)?.value || this.settings.apiSettings.modelName;

            // Update settings
            const updatedSettings: ArtifactSettings = {
                ...this.settings,
                stitchArtifacts,
                flatFileStructure: flatStructure,
                includeTimestampInFilename: includeTimestamp,
                editorSettings: {
                    ...this.settings.editorSettings,
                    theme: editorTheme,
                    fontSize,
                    lineNumbers: lineNumbers as 'on' | 'off' | 'relative',
                    wordWrap: wordWrap as 'on' | 'off',
                    minimap
                },
                apiSettings: {
                    ...this.settings.apiSettings,
                    enableApiContinuation: enableApi,
                    apiKey,
                    modelName
                }
            };

            // Save settings
            await this.storageService.saveSettings(updatedSettings);

            // Show success message
            this.bannerService.showSuccess('Settings saved successfully');

            // Hide panel
            this.hide();
        } catch (error) {
            this.logger.error('SettingsUI: Error saving settings', error);
            this.bannerService.showError('Failed to save settings');
        }
    }

    /**
     * Reset settings to defaults
     */
    private async resetSettings(): Promise<void> {
        try {
            // Confirm reset
            if (!confirm('Reset all settings to defaults?')) {
                return;
            }

            // Save default settings
            await this.storageService.saveSettings(DEFAULT_SETTINGS);

            // Update reference
            this.settings = DEFAULT_SETTINGS;

            // Show success message
            this.bannerService.showSuccess('Settings reset to defaults');

            // Hide and recreate panel to show updated values
            if (this.settingsPanel && this.settingsPanel.parentNode) {
                this.settingsPanel.parentNode.removeChild(this.settingsPanel);
            }
            this.settingsPanel = null;
            this.isVisible = false;

            // Show settings again
            this.show();
        } catch (error) {
            this.logger.error('SettingsUI: Error resetting settings', error);
            this.bannerService.showError('Failed to reset settings');
        }
    }

    /**
     * Handle showSettings message
     */
    private async handleShowSettings(): Promise<boolean> {
        await this.show();
        return true;
    }
}


================================================================================
FILE: content/ui/bannerService.ts
================================================================================

import { LoggerService } from '../../shared/services/loggerService';

/**
 * Service for showing notification banners in the UI
 */
export class BannerService {
    private static instance: BannerService;
    private readonly logger = LoggerService.getInstance();
    private activeNotifications: Set<HTMLElement> = new Set();
    private notificationContainer: HTMLElement | null = null;
    private notificationDuration = 3000; // ms

    private constructor() {
        // Private constructor for singleton
    }

    /**
     * Get the singleton instance of the banner service
     */
    public static getInstance(): BannerService {
        if (!BannerService.instance) {
            BannerService.instance = new BannerService();
        }
        return BannerService.instance;
    }

    /**
     * Set the duration for notifications
     */
    public setNotificationDuration(durationMs: number): void {
        this.notificationDuration = durationMs;
    }

    /**
     * Show a success notification banner
     */
    public showSuccess(message: string, duration?: number): void {
        this.showNotification(message, 'success', duration);
    }

    /**
     * Show an error notification banner
     */
    public showError(message: string, duration?: number): void {
        this.showNotification(message, 'error', duration);
    }

    /**
     * Show an info notification banner
     */
    public showInfo(message: string, duration?: number): void {
        this.showNotification(message, 'info', duration);
    }

    /**
     * Show a warning notification banner
     */
    public showWarning(message: string, duration?: number): void {
        this.showNotification(message, 'warning', duration);
    }

    /**
     * Show a notification banner with custom styling
     */
    private showNotification(message: string, type: 'success' | 'error' | 'info' | 'warning', duration?: number): void {
        this.ensureContainer();

        const notification = this.createNotificationElement(message, type);
        this.notificationContainer!.appendChild(notification);
        this.activeNotifications.add(notification);

        // Add to DOM and trigger animation
        setTimeout(() => {
            notification.style.opacity = '1';
            notification.style.transform = 'translateY(0)';
        }, 10);

        // Set up auto-remove after duration
        const timeoutDuration = duration ?? this.notificationDuration;
        const timeout = setTimeout(() => {
            this.removeNotification(notification);
        }, timeoutDuration);

        // Store timeout ID for potential early removal
        (notification as any)._removeTimeout = timeout;

        // Add click handler to remove on click
        notification.addEventListener('click', () => {
            clearTimeout((notification as any)._removeTimeout);
            this.removeNotification(notification);
        });
    }

    /**
     * Remove a notification with animation
     */
    private removeNotification(notification: HTMLElement): void {
        // Don't remove if already removing
        if (notification.classList.contains('removing')) {
            return;
        }

        notification.classList.add('removing');
        notification.style.opacity = '0';
        notification.style.transform = 'translateY(-10px)';

        // Remove from DOM after animation
        setTimeout(() => {
            if (notification.parentNode) {
                notification.parentNode.removeChild(notification);
            }
            this.activeNotifications.delete(notification);

            // Clean up container if no more notifications
            if (this.activeNotifications.size === 0 && this.notificationContainer) {
                this.notificationContainer.remove();
                this.notificationContainer = null;
            }
        }, 300);
    }

    /**
     * Create the notification element with appropriate styling
     */
    private createNotificationElement(message: string, type: 'success' | 'error' | 'info' | 'warning'): HTMLElement {
        const notification = document.createElement('div');
        notification.className = `artifact-notification artifact-notification-${type}`;
        notification.setAttribute('role', 'alert');

        // Base styles
        Object.assign(notification.style, {
            padding: '12px 16px',
            margin: '0 0 8px 0',
            borderRadius: '6px',
            boxShadow: '0 4px 6px rgba(0, 0, 0, 0.1)',
            fontFamily: 'system-ui, -apple-system, sans-serif',
            fontSize: '14px',
            lineHeight: '1.5',
            display: 'flex',
            alignItems: 'center',
            opacity: '0',
            transform: 'translateY(-10px)',
            transition: 'opacity 0.3s ease, transform 0.3s ease',
            cursor: 'pointer',
            maxWidth: '100%',
            overflow: 'hidden',
            textOverflow: 'ellipsis',
            position: 'relative'
        });

        // Type-specific styles
        const typeStyles = {
            success: {
                backgroundColor: '#ecfdf5',
                color: '#065f46',
                borderLeft: '4px solid #10b981'
            },
            error: {
                backgroundColor: '#fef2f2',
                color: '#991b1b',
                borderLeft: '4px solid #ef4444'
            },
            info: {
                backgroundColor: '#eff6ff',
                color: '#1e40af',
                borderLeft: '4px solid #3b82f6'
            },
            warning: {
                backgroundColor: '#fffbeb',
                color: '#92400e',
                borderLeft: '4px solid #f59e0b'
            }
        };

        Object.assign(notification.style, typeStyles[type]);

        // Create icon based on notification type
        const icon = document.createElement('span');
        icon.style.marginRight = '12px';

        const iconPaths: Record<string, string> = {
            success: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></svg>`,
            error: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line></svg>`,
            info: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg>`,
            warning: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>`
        };

        icon.innerHTML = iconPaths[type];
        notification.appendChild(icon);

        // Add message
        const messageSpan = document.createElement('span');
        messageSpan.textContent = message;
        notification.appendChild(messageSpan);

        return notification;
    }

    /**
     * Ensure the notification container exists in the DOM
     */
    private ensureContainer(): void {
        if (!this.notificationContainer) {
            this.notificationContainer = document.createElement('div');
            this.notificationContainer.className = 'artifact-notification-container';

            // Style the container
            Object.assign(this.notificationContainer.style, {
                position: 'fixed',
                top: '16px',
                right: '16px',
                zIndex: '10000',
                display: 'flex',
                flexDirection: 'column',
                alignItems: 'flex-end',
                maxWidth: '350px',
                pointerEvents: 'none' // Allow clicking through the container
            });

            // Make notifications themselves clickable
            const style = document.createElement('style');
            style.textContent = `
        .artifact-notification {
          pointer-events: auto;
        }
      `;
            this.notificationContainer.appendChild(style);

            document.body.appendChild(this.notificationContainer);
        }
    }

    /**
     * Remove all notifications immediately
     */
    public clearAll(): void {
        if (!this.notificationContainer) return;

        // Clear all timeouts
        this.activeNotifications.forEach(notification => {
            if ((notification as any)._removeTimeout) {
                clearTimeout((notification as any)._removeTimeout);
            }
        });

        // Remove container and reset state
        this.notificationContainer.remove();
        this.notificationContainer = null;
        this.activeNotifications.clear();
    }
}


================================================================================
FILE: content/styles/banner.css
================================================================================

article.error,
article.success {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    margin: 0;
    padding: 1rem;
    text-align: center;
    z-index: 9999;
    animation: slideDown 0.5s ease-out;
}

article.error {
    background-color: #d30c00;
    border-color: #d30c00;
    color: white;
}

article.success {
    background-color: #125019;
    border-color: #125019;
    color: white;
}

article.hide {
    animation: slideUp 0.5s ease-in forwards;
}

@keyframes slideDown {
    from { transform: translateY(-100%); }
    to { transform: translateY(0); }
}

@keyframes slideUp {
    from { transform: translateY(0); }
    to { transform: translateY(-100%); }
}


================================================================================
FILE: content/events/messageService.ts
================================================================================

import { LoggerService } from '../../shared/services/loggerService';

/**
 * Interface for all messages sent between content and background scripts
 */
export interface Message {
    action: string;
    [key: string]: any;
}

/**
 * Service for sending messages between content and background scripts
 */
export class MessageService {
    private static instance: MessageService;
    private readonly logger = LoggerService.getInstance();
    private messageHandlers: Map<string, (message: Message) => Promise<any>> = new Map();

    private constructor() {
        // Set up message listener
        chrome.runtime.onMessage.addListener(this.handleIncomingMessage.bind(this));
    }

    /**
     * Get the singleton instance of the message service
     */
    public static getInstance(): MessageService {
        if (!MessageService.instance) {
            MessageService.instance = new MessageService();
        }
        return MessageService.instance;
    }

    /**
     * Send a message to the background script
     */
    public async sendMessage(message: Message): Promise<any> {
        try {
            this.logger.debug('Sending message:', message);
            const response = await chrome.runtime.sendMessage(message);
            this.logger.debug('Received response:', response);
            return response;
        } catch (error) {
            this.logger.error('Error sending message:', error);
            throw error;
        }
    }

    /**
     * Register a handler for a specific message action
     */
    public registerHandler(action: string, handler: (message: Message) => Promise<any>): void {
        this.messageHandlers.set(action, handler);
        this.logger.debug(`Registered handler for action: ${action}`);
    }

    /**
     * Remove a handler for a specific message action
     */
    public removeHandler(action: string): void {
        this.messageHandlers.delete(action);
        this.logger.debug(`Removed handler for action: ${action}`);
    }

    /**
     * Handle incoming messages and route to appropriate handler
     */
    private handleIncomingMessage(message: Message, sender: chrome.runtime.MessageSender, sendResponse: (response?: any) => void): boolean {
        if (!message || !message.action) {
            this.logger.warn('Received invalid message:', message);
            sendResponse({ success: false, error: 'Invalid message format' });
            return false;
        }

        this.logger.debug('Received message:', message);

        const handler = this.messageHandlers.get(message.action);

        if (!handler) {
            this.logger.debug(`No handler registered for action: ${message.action}`);
            sendResponse({ success: false, error: `No handler for action: ${message.action}` });
            return false;
        }

        // Process with handler and send response
        handler(message)
            .then(result => {
                this.logger.debug('Handler result:', result);
                sendResponse({ success: true, data: result });
            })
            .catch(error => {
                this.logger.error(`Error handling message for action ${message.action}:`, error);
                sendResponse({
                    success: false,
                    error: error instanceof Error ? error.message : 'Unknown error'
                });
            });

        // Return true to indicate we'll use sendResponse asynchronously
        return true;
    }
}


================================================================================
FILE: content/events/rateLimitHandler.ts
================================================================================

import { LoggerService } from '../../shared/services/loggerService';
import { MessageService } from './messageService';
import { BannerService } from '../ui/bannerService';
import { StorageService } from '../../shared/services/storageService';

/**
 * Handler for Claude rate limit detection and API continuation
 */
export class RateLimitHandler {
    private static instance: RateLimitHandler;
    private readonly logger = LoggerService.getInstance();
    private readonly messageService = MessageService.getInstance();
    private readonly bannerService = BannerService.getInstance();
    private readonly storageService = StorageService.getInstance();

    private observer: MutationObserver | null = null;
    private isApiContinuationEnabled = false;
    private isRateLimited = false;
    private continueButton: HTMLButtonElement | null = null;

    private readonly RATE_LIMIT_SELECTORS = [
        '.rate-limit-message',
        '.rate-limited-container',
        '.message-error:contains("rate limit")'
    ];

    private constructor() {
        this.init().catch(error => {
            console.error('RateLimitHandler: Initialization error', error);
        });
    }

    /**
     * Get the singleton instance of the rate limit handler
     */
    public static getInstance(): RateLimitHandler {
        if (!RateLimitHandler.instance) {
            RateLimitHandler.instance = new RateLimitHandler();
        }
        return RateLimitHandler.instance;
    }

    /**
     * Initialize the rate limit handler
     */
    private async init(): Promise<void> {
        try {
            // Load settings
            const settings = await this.storageService.getSettings();
            this.isApiContinuationEnabled = settings.apiSettings.enableApiContinuation;

            // Start observing for rate limit messages
            this.startObserver();

            this.logger.debug('RateLimitHandler: Initialized');
        } catch (error) {
            this.logger.error('RateLimitHandler: Initialization failed', error);
        }
    }

    /**
     * Start observing for rate limit messages
     */
    private startObserver(): void {
        if (this.observer) {
            this.observer.disconnect();
        }

        this.observer = new MutationObserver(this.handleDomMutations.bind(this));
        this.observer.observe(document.body, {
            childList: true,
            subtree: true
        });

        // Also check immediately
        this.checkForRateLimit();
    }

    /**
     * Handle DOM mutations
     */
    private handleDomMutations(mutations: MutationRecord[]): void {
        // Only process if we have new nodes added
        const hasNewNodes = mutations.some(mutation =>
            mutation.type === 'childList' && mutation.addedNodes.length > 0);

        if (hasNewNodes) {
            this.checkForRateLimit();
        }
    }

    /**
     * Check for rate limit messages in the DOM
     */
    private checkForRateLimit(): void {
        // Skip if already handling rate limit or API continuation disabled
        if (this.isRateLimited || !this.isApiContinuationEnabled) {
            return;
        }

        // Check for rate limit messages
        for (const selector of this.RATE_LIMIT_SELECTORS) {
            const element = document.querySelector(selector);
            if (element) {
                this.handleRateLimit(element as HTMLElement);
                break;
            }
        }
    }

    /**
     * Handle rate limit detection
     */
    private async handleRateLimit(element: HTMLElement): Promise<void> {
        try {
            this.isRateLimited = true;
            this.logger.info('RateLimitHandler: Rate limit detected');

            // Check if API continuation is enabled and API key is set
            const settings = await this.storageService.getSettings();
            if (!settings.apiSettings.enableApiContinuation) {
                this.logger.debug('RateLimitHandler: API continuation disabled in settings');
                return;
            }

            if (!settings.apiSettings.apiKey) {
                this.bannerService.showWarning('API key not set. Please configure in settings to continue via API.');
                return;
            }

            // Add continue button
            this.addContinueButton(element);
        } catch (error) {
            this.logger.error('RateLimitHandler: Error handling rate limit', error);
        }
    }

    /**
     * Add a button to continue conversation via API
     */
    private addContinueButton(container: HTMLElement): void {
        // Check if button already exists
        if (this.continueButton || container.querySelector('.api-continue-button')) {
            return;
        }

        // Create button
        const button = document.createElement('button');
        button.className = 'api-continue-button';
        button.textContent = 'Continue with API';

        // Add styling
        Object.assign(button.style, {
            backgroundColor: '#2563eb',
            color: 'white',
            border: 'none',
            borderRadius: '4px',
            padding: '8px 16px',
            marginTop: '12px',
            cursor: 'pointer',
            fontWeight: '500',
            fontSize: '14px'
        });

        // Add event listener
        button.addEventListener('click', this.handleContinueClick.bind(this));

        // Add to container
        container.appendChild(button);
        this.continueButton = button;
    }

    /**
     * Handle continue button click
     */
    private async handleContinueClick(): Promise<void> {
        try {
            if (!this.continueButton) return;

            // Update button state
            this.continueButton.disabled = true;
            this.continueButton.textContent = 'Continuing...';

            // Extract current conversation context
            const conversationContext = this.extractConversationContext();

            // Send to background script for API continuation
            const response = await this.messageService.sendMessage({
                action: 'apiRequest',
                prompt: conversationContext.lastMessage,
                options: {
                    context: conversationContext.history
                }
            });

            if (response.success) {
                // Display API response
                this.displayApiResponse(response.data);

                // Clear rate limited state
                this.isRateLimited = false;

                // Show success message
                this.bannerService.showSuccess('Successfully continued with API');
            } else {
                throw new Error(response.error || 'Failed to continue with API');
            }
        } catch (error) {
            this.logger.error('RateLimitHandler: Error continuing with API', error);
            this.bannerService.showError('Failed to continue with API');

            // Reset button
            if (this.continueButton) {
                this.continueButton.disabled = false;
                this.continueButton.textContent = 'Continue with API';
            }
        }
    }

    /**
     * Extract conversation context
     */
    private extractConversationContext(): { history: string[], lastMessage: string } {
        // Implementation would extract conversation history from DOM
        const history: string[] = [];
        let lastMessage = '';

        // Find conversation container
        const conversationContainer = document.querySelector('.conversation-container');
        if (conversationContainer) {
            // Extract message elements
            const messageElements = conversationContainer.querySelectorAll('.message');

            messageElements.forEach(element => {
                const content = element.textContent || '';
                history.push(content);
            });

            // Extract last user message
            const lastUserMessage = conversationContainer.querySelector('.message.user:last-child');
            if (lastUserMessage) {
                lastMessage = lastUserMessage.textContent || '';
            }
        }

        return { history, lastMessage };
    }

    /**
     * Display API response in the UI
     */
    private displayApiResponse(apiResponse: any): void {
        // Implementation would display the API response in the UI
        // This could be complex and would interact with Claude's UI

        // For now, just show a message with the API result
        this.bannerService.showInfo('API response received. Displaying would require deep integration.');

        // Log the response
        this.logger.debug('RateLimitHandler: API response', apiResponse);
    }

    /**
     * Destroy the rate limit handler
     */
    public destroy(): void {
        if (this.observer) {
            this.observer.disconnect();
            this.observer = null;
        }

        if (this.continueButton && this.continueButton.parentNode) {
            this.continueButton.parentNode.removeChild(this.continueButton);
        }

        this.continueButton = null;
        this.isRateLimited = false;

        this.logger.debug('RateLimitHandler: Destroyed');
    }
}


================================================================================
FILE: content/editor/monacoEditorService.ts
================================================================================

import { LoggerService } from '../../shared/services/loggerService';

/**
 * Service for managing Monaco editor instances
 */
export class MonacoEditorService {
    private static instance: MonacoEditorService;
    private readonly logger = LoggerService.getInstance();
    private isMonacoLoaded = false;
    private loadPromise: Promise<void> | null = null;

    // CDN URL for Monaco editor
    private readonly MONACO_CDN_BASE = 'https://cdn.jsdelivr.net/npm/monaco-editor@0.40.0/min';

    // List of editors created by this service
    private editors: monaco.editor.IStandaloneCodeEditor[] = [];

    private constructor() {
        // Private constructor for singleton
    }

    /**
     * Get the singleton instance of the Monaco editor service
     */
    public static getInstance(): MonacoEditorService {
        if (!MonacoEditorService.instance) {
            MonacoEditorService.instance = new MonacoEditorService();
        }
        return MonacoEditorService.instance;
    }

    /**
     * Ensure Monaco editor is loaded
     */
    public ensureMonacoLoaded(): Promise<void> {
        if (this.isMonacoLoaded) {
            return Promise.resolve();
        }

        if (this.loadPromise) {
            return this.loadPromise;
        }

        this.loadPromise = this.loadMonaco();
        return this.loadPromise;
    }

    /**
     * Load Monaco editor from CDN
     */
    private async loadMonaco(): Promise<void> {
        this.logger.debug('MonacoEditorService: Loading Monaco editor from CDN');

        try {
            // Add Monaco loader script
            await this.loadScript(`${this.MONACO_CDN_BASE}/vs/loader.js`);

            // Configure AMD loader for Monaco
            (window as any).require.config({
                paths: {
                    vs: `${this.MONACO_CDN_BASE}/vs`
                }
            });

            // Load Monaco editor
            return new Promise<void>((resolve, reject) => {
                try {
                    (window as any).require(['vs/editor/editor.main'], () => {
                        this.isMonacoLoaded = true;
                        this.logger.info('MonacoEditorService: Monaco editor loaded successfully');
                        resolve();
                    });
                } catch (error) {
                    reject(error);
                }
            });
        } catch (error) {
            this.logger.error('MonacoEditorService: Failed to load Monaco editor', error);
            this.loadPromise = null;
            throw error;
        }
    }

    /**
     * Load a script from URL
     */
    private loadScript(url: string): Promise<void> {
        return new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = url;
            script.onload = () => resolve();
            script.onerror = (e) => reject(new Error(`Failed to load script: ${url}`));
            document.head.appendChild(script);
        });
    }

    /**
     * Create a Monaco editor instance
     */
    public createEditor(
        container: HTMLElement,
        options: monaco.editor.IStandaloneEditorConstructionOptions
    ): monaco.editor.IStandaloneCodeEditor {
        if (!this.isMonacoLoaded) {
            throw new Error('Monaco editor not loaded. Call ensureMonacoLoaded() first.');
        }

        const defaultOptions: monaco.editor.IStandaloneEditorConstructionOptions = {
            minimap: { enabled: true },
            lineNumbers: 'on',
            scrollBeyondLastLine: false,
            theme: 'vs',
            fontSize: 14,
            wordWrap: 'on',
            automaticLayout: true
        };

        const editorOptions = { ...defaultOptions, ...options };
        const editor = monaco.editor.create(container, editorOptions);

        // Store editor reference for cleanup
        this.editors.push(editor);

        return editor;
    }

    /**
     * Set theme for all editors
     */
    public setTheme(theme: 'vs' | 'vs-dark' | 'hc-black'): void {
        if (!this.isMonacoLoaded) return;

        monaco.editor.setTheme(theme);
        this.logger.debug(`MonacoEditorService: Set theme to ${theme}`);
    }

    /**
     * Dispose of a specific editor
     */
    public disposeEditor(editor: monaco.editor.IStandaloneCodeEditor): void {
        if (!editor) return;

        editor.dispose();
        this.editors = this.editors.filter(e => e !== editor);
        this.logger.debug('MonacoEditorService: Editor disposed');
    }

    /**
     * Dispose of all editors
     */
    public disposeAllEditors(): void {
        this.editors.forEach(editor => editor.dispose());
        this.editors = [];
        this.logger.info('MonacoEditorService: All editors disposed');
    }

    /**
     * Register a custom language for Monaco
     */
    public registerLanguage(languageId: string, configuration: any): void {
        if (!this.isMonacoLoaded) return;

        monaco.languages.register({ id: languageId });
        monaco.languages.setMonarchTokensProvider(languageId, configuration);
        this.logger.debug(`MonacoEditorService: Registered custom language ${languageId}`);
    }
}


================================================================================
FILE: content/editor/compilerService.ts
================================================================================

import { LoggerService } from '../../shared/services/loggerService';
import { MessageService } from '../events/messageService';

/**
 * Represents a compiler result
 */
interface CompilerResult {
    output: string | any;
    error?: string;
    executionTime?: number;
}

/**
 * Service for compiling and running code
 */
export class CompilerService {
    private static instance: CompilerService;
    private readonly logger = LoggerService.getInstance();
    private readonly messageService = MessageService.getInstance();

    private constructor() {
        // Register message handler for compiler requests
        this.messageService.registerHandler('compileAndRun', this.handleCompileAndRun.bind(this));
    }

    /**
     * Get the singleton instance of the compiler service
     */
    public static getInstance(): CompilerService {
        if (!CompilerService.instance) {
            CompilerService.instance = new CompilerService();
        }
        return CompilerService.instance;
    }

    /**
     * Handle compile and run message requests
     */
    private async handleCompileAndRun(message: any): Promise<CompilerResult> {
        const { code, language } = message;

        if (!code || !language) {
            return { output: '', error: 'Missing code or language' };
        }

        return this.compileAndRun(code, language);
    }

    /**
     * Compile and run code using the appropriate engine
     */
    public async compileAndRun(code: string, language: string): Promise<CompilerResult> {
        this.logger.debug(`CompilerService: Compiling ${language} code`);

        try {
            // Safety checks
            if (!code.trim()) {
                return { output: '', error: 'No code provided' };
            }

            // Choose compiler based on language
            switch (language.toLowerCase()) {
                case 'javascript':
                case 'js':
                    return this.runJavaScript(code);

                case 'typescript':
                case 'ts':
                    return await this.runTypeScript(code);

                case 'html':
                    return this.runHtml(code);

                default:
                    // For other languages, send to background script for remote compilation
                    return this.remoteCompile(code, language);
            }
        } catch (error) {
            this.logger.error('CompilerService: Compilation error', error);
            return {
                output: '',
                error: error instanceof Error ? error.message : 'Unknown error during compilation'
            };
        }
    }

    /**
     * Run JavaScript code in a sandboxed environment
     */
    private runJavaScript(code: string): CompilerResult {
        try {
            const startTime = performance.now();

            // Create a sandboxed environment
            const sandbox = this.createSandbox();

            // Add timeout protection
            const timeoutCode = `
        let __timeout_id;
        const __executeWithTimeout = () => {
          return new Promise((resolve, reject) => {
            __timeout_id = setTimeout(() => {
              reject(new Error('Execution timed out (5000ms)'));
            }, 5000);
            
            try {
              const result = (function() { ${code} })();
              clearTimeout(__timeout_id);
              resolve(result);
            } catch (error) {
              clearTimeout(__timeout_id);
              reject(error);
            }
          });
        };
        
        __executeWithTimeout();
      `;

            // Execute in the sandbox and capture console output
            const result = sandbox.eval(timeoutCode);
            const executionTime = performance.now() - startTime;

            return {
                output: sandbox.getConsoleOutput(),
                executionTime
            };
        } catch (error) {
            return {
                output: '',
                error: error instanceof Error ? error.message : 'Unknown error during execution'
            };
        }
    }

    /**
     * Run TypeScript code by transpiling then executing as JavaScript
     */
    private async runTypeScript(code: string): Promise<CompilerResult> {
        try {
            // Load TypeScript compiler from CDN if needed
            if (!(window as any).ts) {
                await this.loadTypescriptCompiler();
            }

            const ts = (window as any).ts;

            // Transpile TypeScript to JavaScript
            const transpileOutput = ts.transpileModule(code, {
                compilerOptions: {
                    module: ts.ModuleKind.ESNext,
                    target: ts.ScriptTarget.ES2020,
                    strict: false,
                    esModuleInterop: true
                }
            });

            const jsCode = transpileOutput.outputText;

            // Execute the JavaScript code
            return this.runJavaScript(jsCode);
        } catch (error) {
            return {
                output: '',
                error: error instanceof Error ? error.message : 'TypeScript compilation error'
            };
        }
    }

    /**
     * Load TypeScript compiler from CDN
     */
    private async loadTypescriptCompiler(): Promise<void> {
        return new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = 'https://cdn.jsdelivr.net/npm/typescript@5.0.4/lib/typescript.min.js';
            script.onload = () => resolve();
            script.onerror = () => reject(new Error('Failed to load TypeScript compiler'));
            document.head.appendChild(script);
        });
    }

    /**
     * Run HTML code by creating a sandboxed iframe
     */
    private runHtml(code: string): CompilerResult {
        try {
            // Create a hidden iframe for rendering HTML
            const iframe = document.createElement('iframe');
            iframe.style.display = 'none';
            document.body.appendChild(iframe);

            // Set content to the iframe
            const doc = iframe.contentDocument || iframe.contentWindow?.document;
            if (!doc) {
                throw new Error('Failed to access iframe document');
            }

            doc.open();
            doc.write(code);
            doc.close();

            // Capture console logs from the iframe
            const consoleOutput: string[] = [];
            const originalConsole = iframe.contentWindow?.console;
            if (iframe.contentWindow) {
                iframe.contentWindow.console = {
                    ...originalConsole,
                    log: (...args: any[]) => {
                        originalConsole?.log(...args);
                        consoleOutput.push(args.map(arg => String(arg)).join(' '));
                    },
                    error: (...args: any[]) => {
                        originalConsole?.error(...args);
                        consoleOutput.push(`ERROR: ${args.map(arg => String(arg)).join(' ')}`);
                    },
                    warn: (...args: any[]) => {
                        originalConsole?.warn(...args);
                        consoleOutput.push(`WARNING: ${args.map(arg => String(arg)).join(' ')}`);
                    }
                } as Console;
            }

            // Return the rendered HTML and console output
            setTimeout(() => {
                document.body.removeChild(iframe);
            }, 1000);

            return {
                output: {
                    html: doc.documentElement.outerHTML,
                    consoleOutput: consoleOutput.join('\n')
                }
            };
        } catch (error) {
            return {
                output: '',
                error: error instanceof Error ? error.message : 'HTML rendering error'
            };
        }
    }

    /**
     * Remote compile code for languages that can't be run in browser
     */
    private async remoteCompile(code: string, language: string): Promise<CompilerResult> {
        try {
            // Send to background script for remote compilation
            const response = await this.messageService.sendMessage({
                action: 'remoteCompile',
                code,
                language
            });

            if (response.success) {
                return response.data;
            } else {
                return {
                    output: '',
                    error: response.error || `Remote compilation not available for ${language}`
                };
            }
        } catch (error) {
            return {
                output: '',
                error: error instanceof Error ?
                    error.message :
                    `Remote compilation failed for ${language}`
            };
        }
    }

    /**
     * Create a sandboxed environment for executing JavaScript
     */
    private createSandbox() {
        const consoleOutput: string[] = [];

        // Create sandbox object with limited access to globals
        const sandbox = {
            console: {
                log: (...args: any[]) => {
                    consoleOutput.push(args.map(arg => this.stringifyValue(arg)).join(' '));
                },
                error: (...args: any[]) => {
                    consoleOutput.push(`ERROR: ${args.map(arg => this.stringifyValue(arg)).join(' ')}`);
                },
                warn: (...args: any[]) => {
                    consoleOutput.push(`WARNING: ${args.map(arg => this.stringifyValue(arg)).join(' ')}`);
                },
                info: (...args: any[]) => {
                    consoleOutput.push(`INFO: ${args.map(arg => this.stringifyValue(arg)).join(' ')}`);
                }
            },
            setTimeout: setTimeout.bind(window),
            clearTimeout: clearTimeout.bind(window),
            setInterval: setInterval.bind(window),
            clearInterval: clearInterval.bind(window),
            Math: Math,
            Date: Date,
            JSON: JSON,
            Object: Object,
            Array: Array,
            String: String,
            Number: Number,
            Boolean: Boolean,
            RegExp: RegExp,
            Error: Error,
            Map: Map,
            Set: Set,
            Promise: Promise,
            eval: function(code: string) {
                const fn = new Function('sandbox', `with(sandbox) { return ${code} }`);
                return fn(sandbox);
            },
            getConsoleOutput: () => consoleOutput.join('\n')
        };

        return sandbox;
    }

    /**
     * Helper to stringify complex values for console output
     */
    private stringifyValue(value: any): string {
        if (value === null) return 'null';
        if (value === undefined) return 'undefined';

        if (typeof value === 'object') {
            try {
                return JSON.stringify(value);
            } catch (e) {
                return '[Object]';
            }
        }

        return String(value);
    }
}


================================================================================
FILE: content/editor/artifactUIHandler.ts
================================================================================

import { LoggerService } from '../../shared/services/loggerService';
import { BannerService } from '../ui/bannerService';
import { EditorManager } from './editorManager';
import { CompilerService } from './compilerService';

/**
 * Handler for artifact UI interactions
 */
export class ArtifactUIHandler {
    private static instance: ArtifactUIHandler;
    private readonly logger = LoggerService.getInstance();
    private readonly bannerService = BannerService.getInstance();
    private readonly editorManager = EditorManager.getInstance();
    private readonly compilerService = CompilerService.getInstance();

    private observer: MutationObserver | null = null;

    private constructor() {
        // Private constructor for singleton
    }

    /**
     * Get the singleton instance of the artifact UI handler
     */
    public static getInstance(): ArtifactUIHandler {
        if (!ArtifactUIHandler.instance) {
            ArtifactUIHandler.instance = new ArtifactUIHandler();
        }
        return ArtifactUIHandler.instance;
    }

    /**
     * Initialize the artifact UI handler
     */
    public init(): void {
        this.startObserver();
        this.logger.debug('ArtifactUIHandler: Initialized');
    }

    /**
     * Start the mutation observer to watch for new artifacts
     */
    private startObserver(): void {
        if (this.observer) {
            this.observer.disconnect();
        }

        this.observer = new MutationObserver(this.handleDomMutations.bind(this));
        this.observer.observe(document.body, {
            childList: true,
            subtree: true
        });

        // Process existing artifacts
        this.processExistingArtifacts();
    }

    /**
     * Handle DOM mutations
     */
    private handleDomMutations(mutations: MutationRecord[]): void {
        // Only process if we have new nodes added
        const hasNewNodes = mutations.some(mutation =>
            mutation.type === 'childList' && mutation.addedNodes.length > 0);

        if (hasNewNodes) {
            // Look for new artifacts
            const addedArtifacts = mutations
                .filter(mutation => mutation.type === 'childList' && mutation.addedNodes.length > 0)
                .reduce((nodes: HTMLElement[], mutation) => {
                    mutation.addedNodes.forEach(node => {
                        if (node instanceof HTMLElement) {
                            // Check if this is an artifact container
                            if (node.classList.contains('antml-artifact-container')) {
                                nodes.push(node);
                            } else {
                                // Check for artifact containers within this node
                                const containers = node.querySelectorAll('.antml-artifact-container');
                                containers.forEach(container => nodes.push(container as HTMLElement));
                            }
                        }
                    });
                    return nodes;
                }, []);

            // Process any new artifacts found
            if (addedArtifacts.length > 0) {
                this.processNewArtifacts(addedArtifacts);
            }
        }
    }

    /**
     * Process existing artifacts in the DOM
     */
    private processExistingArtifacts(): void {
        const artifacts = document.querySelectorAll('.antml-artifact-container');

        if (artifacts.length > 0) {
            this.logger.debug(`ArtifactUIHandler: Found ${artifacts.length} existing artifacts`);
            this.processNewArtifacts(Array.from(artifacts) as HTMLElement[]);
        }
    }

    /**
     * Process new artifacts
     */
    private processNewArtifacts(artifacts: HTMLElement[]): void {
        artifacts.forEach(artifact => {
            // Skip already processed artifacts
            if (artifact.querySelector('.artifact-controls')) {
                return;
            }

            this.enhanceArtifact(artifact);
        });
    }

    /**
     * Enhance an artifact with additional controls
     */
    private enhanceArtifact(container: HTMLElement): void {
        try {
            // Find the title element to add controls next to
            const titleElement = container.querySelector('.antml-artifact-title');
            if (!titleElement) {
                return;
            }

            // Create controls container
            const controlsContainer = document.createElement('div');
            controlsContainer.className = 'artifact-controls';
            Object.assign(controlsContainer.style, {
                display: 'flex',
                gap: '8px',
                marginLeft: 'auto'
            });

            // Add edit button
            const editButton = this.createEditButton();
            controlsContainer.appendChild(editButton);

            // Add copy button
            const copyButton = this.createCopyButton();
            controlsContainer.appendChild(copyButton);

            // Add run button for code artifacts
            const isCodeArtifact = container.classList.contains('code-artifact') ||
                container.querySelector('pre code') !== null;

            if (isCodeArtifact) {
                const runButton = this.createRunButton();
                controlsContainer.appendChild(runButton);
            }

            // Add controls to the title element
            Object.assign(titleElement.style, {
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'space-between'
            });

            titleElement.appendChild(controlsContainer);

            // Store artifact data
            this.storeArtifactData(container);

            this.logger.debug('ArtifactUIHandler: Enhanced artifact', container);
        } catch (error) {
            this.logger.error('ArtifactUIHandler: Error enhancing artifact', error);
        }
    }

    /**
     * Create an edit button
     */
    private createEditButton(): HTMLButtonElement {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'artifact-edit-button';
        button.title = 'Edit this artifact';
        button.innerHTML = `
      <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
        <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
      </svg>
      <span>Edit</span>
    `;

        // Add styling
        Object.assign(button.style, {
            display: 'flex',
            alignItems: 'center',
            gap: '4px',
            padding: '4px 8px',
            borderRadius: '4px',
            border: '1px solid #e2e8f0',
            backgroundColor: '#f8fafc',
            color: '#334155',
            cursor: 'pointer',
            fontSize: '12px',
            fontWeight: '500'
        });

        // Add event listener
        button.addEventListener('click', (event) => {
            const artifactContainer = (event.target as HTMLElement)
                .closest('.antml-artifact-container') as HTMLElement;

            if (artifactContainer) {
                this.handleArtifactEdit(artifactContainer, button);
            }
        });

        return button;
    }

    /**
     * Create a copy button
     */
    private createCopyButton(): HTMLButtonElement {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'artifact-copy-button';
        button.title = 'Copy this artifact';
        button.innerHTML = `
      <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
        <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
      </svg>
      <span>Copy</span>
    `;

        // Add styling
        Object.assign(button.style, {
            display: 'flex',
            alignItems: 'center',
            gap: '4px',
            padding: '4px 8px',
            borderRadius: '4px',
            border: '1px solid #e2e8f0',
            backgroundColor: '#f8fafc',
            color: '#334155',
            cursor: 'pointer',
            fontSize: '12px',
            fontWeight: '500'
        });

        // Add event listener
        button.addEventListener('click', (event) => {
            const artifactContainer = (event.target as HTMLElement)
                .closest('.antml-artifact-container') as HTMLElement;

            if (artifactContainer) {
                this.handleArtifactCopy(artifactContainer, button);
            }
        });

        return button;
    }

    /**
     * Create a run button for code artifacts
     */
    private createRunButton(): HTMLButtonElement {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'artifact-run-button';
        button.title = 'Run this code';
        button.innerHTML = `
      <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <polygon points="5 3 19 12 5 21 5 3"></polygon>
      </svg>
      <span>Run</span>
    `;

        // Add styling
        Object.assign(button.style, {
            display: 'flex',
            alignItems: 'center',
            gap: '4px',
            padding: '4px 8px',
            borderRadius: '4px',
            border: '1px solid #d1fae5',
            backgroundColor: '#ecfdf5',
            color: '#065f46',
            cursor: 'pointer',
            fontSize: '12px',
            fontWeight: '500'
        });

        // Add event listener
        button.addEventListener('click', (event) => {
            const artifactContainer = (event.target as HTMLElement)
                .closest('.antml-artifact-container') as HTMLElement;

            if (artifactContainer) {
                this.handleArtifactRun(artifactContainer);
            }
        });

        return button;
    }

    /**
     * Store artifact data
     */
    private storeArtifactData(container: HTMLElement): void {
        // Extract metadata
        const titleElement = container.querySelector('.antml-artifact-title') as HTMLElement;
        const title = titleElement?.textContent?.trim() || 'Untitled';

        // Determine artifact type
        let type = 'text';
        if (container.classList.contains('code-artifact') || container.querySelector('pre code')) {
            type = 'code';
        } else if (container.querySelector('svg')) {
            type = 'svg';
        } else if (container.querySelector('table')) {
            type = 'table';
        }

        // Get language for code artifacts
        let language = '';
        const codeElement = container.querySelector('pre code');
        if (codeElement) {
            const classNames = Array.from(codeElement.classList);
            const langClass = classNames.find(cls => cls.startsWith('language-'));
            if (langClass) {
                language = langClass.replace('language-', '');
            }
        }

        // Store as data attribute
        container.dataset.artifactMetadata = JSON.stringify({
            title,
            type,
            language,
            timestamp: new Date().toISOString()
        });
    }

    /**
     * Handle edit button click
     */
    private async handleArtifactEdit(container: HTMLElement, button: HTMLButtonElement): Promise<void> {
        try {
            const isEditMode = container.classList.contains('editing-mode');

            if (isEditMode) {
                // Save changes
                await this.editorManager.saveChanges(container);
                button.innerHTML = `
          <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
            <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
          </svg>
          <span>Edit</span>
        `;
            } else {
                // Enter edit mode
                await this.editorManager.createEditor(container);
                button.innerHTML = `
          <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
            <polyline points="17 21 17 13 7 13 7 21"></polyline>
            <polyline points="7 3 7 8 15 8"></polyline>
          </svg>
          <span>Save</span>
        `;
            }
        } catch (error) {
            this.logger.error('ArtifactUIHandler: Edit error', error);
            this.bannerService.showError('Failed to edit artifact');
        }
    }

    /**
     * Handle copy button click
     */
    private handleArtifactCopy(container: HTMLElement, button: HTMLButtonElement): void {
        try {
            // Get content to copy
            let content = '';

            if (container.classList.contains('editing-mode')) {
                // Get from Monaco editor
                content = this.editorManager.getEditorContent(container) || '';
            } else {
                // Get from DOM
                const codeElement = container.querySelector('pre code');
                if (codeElement) {
                    content = codeElement.textContent || '';
                } else {
                    const preElement = container.querySelector('pre');
                    if (preElement) {
                        content = preElement.textContent || '';
                    } else {
                        content = container.textContent || '';
                    }
                }
            }

            // Copy to clipboard
            navigator.clipboard.writeText(content);

            // Update button temporarily
            const originalHTML = button.innerHTML;
            button.innerHTML = `
        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <polyline points="20 6 9 17 4 12"></polyline>
        </svg>
        <span>Copied!</span>
      `;

            // Reset button after delay
            setTimeout(() => {
                button.innerHTML = originalHTML;
            }, 2000);

            // Show notification
            this.bannerService.showSuccess('Copied to clipboard');
        } catch (error) {
            this.logger.error('ArtifactUIHandler: Copy error', error);
            this.bannerService.showError('Failed to copy artifact');
        }
    }

    /**
     * Handle run button click
     */
    private async handleArtifactRun(container: HTMLElement): Promise<void> {
        try {
            // Get metadata
            const metadata = this.extractArtifactMetadata(container);

            if (!metadata || metadata.type !== 'code') {
                this.bannerService.showError('Can only run code artifacts');
                return;
            }

            // Get code content
            let code: string;

            if (container.classList.contains('editing-mode')) {
                // Get from Monaco editor
                code = this.editorManager.getEditorContent(container) || '';
            } else {
                // Get from pre element
                const codeElement = container.querySelector('pre code');
                code = codeElement?.textContent || '';
            }

            if (!code.trim()) {
                this.bannerService.showError('No code to run');
                return;
            }

            // Show compiling message
            this.bannerService.showInfo('Compiling code...');

            // Run the code
            const result = await this.compilerService.compileAndRun(code, metadata.language || 'javascript');

            // Display result
            this.displayCompilationResult(container, result);
        } catch (error) {
            this.logger.error('ArtifactUIHandler: Run error', error);
            this.bannerService.showError('Failed to run code');
        }
    }

    /**
     * Extract artifact metadata
     */
    private extractArtifactMetadata(container: HTMLElement): any {
        try {
            const metadataStr = container.dataset.artifactMetadata;
            if (metadataStr) {
                return JSON.parse(metadataStr);
            }
        } catch (error) {
            this.logger.error('ArtifactUIHandler: Failed to parse metadata', error);
        }
        return null;
    }

    /**
     * Display compilation result
     */
    private displayCompilationResult(container: HTMLElement, result: any): void {
        // Check if output container already exists
        let outputContainer = container.querySelector('.compilation-output');

        if (!outputContainer) {
            // Create new output container
            outputContainer = document.createElement('div');
            outputContainer.className = 'compilation-output';
            Object.assign(outputContainer.style, {
                marginTop: '12px',
                padding: '12px',
                backgroundColor: '#f8fafc',
                borderRadius: '4px',
                border: '1px solid #e2e8f0',
                maxHeight: '300px',
                overflow: 'auto',
                fontSize: '14px',
                fontFamily: 'monospace'
            });

            container.appendChild(outputContainer);
        }

        // Clear previous content
        outputContainer.innerHTML = '';

        // Add header
        const header = document.createElement('div');
        header.style.fontWeight = 'bold';
        header.style.marginBottom = '8px';
        header.style.display = 'flex';
        header.style.justifyContent = 'space-between';
        header.innerHTML = `
      <span>Execution Results</span>
      <span class="close-output" style="cursor:pointer"></span>
    `;
        outputContainer.appendChild(header);

        // Add close button handler
        header.querySelector('.close-output')?.addEventListener('click', () => {
            outputContainer?.remove();
        });

        // Add content based on result type
        if (result.error) {
            const errorDiv = document.createElement('div');
            errorDiv.style.color = '#ef4444';
            errorDiv.textContent = result.error;
            outputContainer.appendChild(errorDiv);
        } else {
            // Create content based on result type
            if (typeof result.output === 'string') {
                const outputPre = document.createElement('pre');
                outputPre.style.margin = '0';
                outputPre.style.whiteSpace = 'pre-wrap';
                outputPre.textContent = result.output;
                outputContainer.appendChild(outputPre);
            } else {
                try {
                    const outputPre = document.createElement('pre');
                    outputPre.style.margin = '0';
                    outputPre.style.whiteSpace = 'pre-wrap';
                    outputPre.textContent = JSON.stringify(result.output, null, 2);
                    outputContainer.appendChild(outputPre);
                } catch (e) {
                    const outputDiv = document.createElement('div');
                    outputDiv.textContent = 'Complex output (cannot display)';
                    outputContainer.appendChild(outputDiv);
                }
            }
        }
    }

    /**
     * Destroy the artifact UI handler
     */
    public destroy(): void {
        if (this.observer) {
            this.observer.disconnect();
            this.observer = null;
        }

        this.logger.debug('ArtifactUIHandler: Destroyed');
    }
}


================================================================================
FILE: content/editor/editorManager.ts
================================================================================

import { MonacoEditorService } from './monacoEditorService';
import { LoggerService } from '../../shared/services/loggerService';
import { BannerService } from '../ui/bannerService';
import { StorageService } from '../../shared/services/storageService';
import { ArtifactSettings } from '../../shared/models/settings';

/**
 * Manages Monaco editors for artifacts
 */
export class EditorManager {
    private static instance: EditorManager;
    private readonly logger = LoggerService.getInstance();
    private readonly bannerService = BannerService.getInstance();
    private readonly storageService = StorageService.getInstance();
    private readonly monacoService = MonacoEditorService.getInstance();

    // Map of artifact container elements to their editor instances
    private editorMap = new Map<HTMLElement, monaco.editor.IStandaloneCodeEditor>();
    private settings: ArtifactSettings | null = null;

    private constructor() {
        this.loadSettings();
    }

    /**
     * Get the singleton instance of the editor manager
     */
    public static getInstance(): EditorManager {
        if (!EditorManager.instance) {
            EditorManager.instance = new EditorManager();
        }
        return EditorManager.instance;
    }

    /**
     * Load settings from storage
     */
    private async loadSettings(): Promise<void> {
        try {
            this.settings = await this.storageService.getSettings();
        } catch (error) {
            this.logger.error('EditorManager: Failed to load settings', error);
        }
    }

    /**
     * Create a Monaco editor for an artifact container
     */
    public async createEditor(container: HTMLElement): Promise<monaco.editor.IStandaloneCodeEditor | null> {
        if (!container) {
            this.logger.error('EditorManager: Container element is required');
            return null;
        }

        // Check if an editor already exists for this container
        if (this.editorMap.has(container)) {
            this.logger.debug('EditorManager: Editor already exists for this container');
            return this.editorMap.get(container) ?? null;
        }

        try {
            // Extract artifact metadata
            const metadata = this.extractArtifactMetadata(container);

            // Get the content to edit
            const content = this.extractArtifactContent(container);

            // Determine language from metadata or try to detect it
            const language = metadata?.language || this.detectLanguage(container, content);

            // Create editor container element
            const editorContainer = document.createElement('div');
            editorContainer.className = 'monaco-editor-container';
            Object.assign(editorContainer.style, {
                width: '100%',
                height: '300px',
                minHeight: '100px',
                border: '1px solid #e2e8f0',
                borderRadius: '4px',
                overflow: 'hidden',
                marginTop: '8px'
            });

            // Find where to insert the editor
            const codeElement = container.querySelector('pre');
            if (codeElement) {
                // Hide the original code element
                codeElement.style.display = 'none';

                // Insert editor after the code element
                codeElement.parentNode?.insertBefore(editorContainer, codeElement.nextSibling);
            } else {
                // No code element found, append to container
                container.appendChild(editorContainer);
            }

            // Ensure Monaco is loaded
            await this.monacoService.ensureMonacoLoaded();

            // Create editor with settings
            const editor = this.monacoService.createEditor(editorContainer, {
                value: content,
                language: language,
                theme: this.settings?.editorSettings.theme || 'vs',
                automaticLayout: true,
                minimap: {
                    enabled: this.settings?.editorSettings.minimap || true
                },
                lineNumbers: this.settings?.editorSettings.lineNumbers || 'on',
                wordWrap: this.settings?.editorSettings.wordWrap || 'on',
                fontSize: this.settings?.editorSettings.fontSize || 14,
                tabSize: this.settings?.editorSettings.tabSize || 2,
                insertSpaces: this.settings?.editorSettings.insertSpaces || true,
                folding: this.settings?.editorSettings.folding || true,
                scrollBeyondLastLine: false,
                roundedSelection: true,
                renderWhitespace: 'none',
                fontFamily: 'Menlo, Monaco, "Courier New", monospace',
                renderLineHighlight: 'all'
            });

            // Mark container as in editing mode
            container.classList.add('editing-mode');

            // Store editor reference
            this.editorMap.set(container, editor);

            // Add resize handle
            this.addResizeHandle(editorContainer, editor);

            // Update layout after a brief delay to ensure proper sizing
            setTimeout(() => {
                editor.layout();
                editor.focus();
            }, 100);

            this.logger.info(`EditorManager: Created editor for language ${language}`);
            return editor;
        } catch (error) {
            this.logger.error('EditorManager: Failed to create editor', error);
            this.bannerService.showError('Failed to create editor');
            return null;
        }
    }

    /**
     * Extract content from an artifact container
     */
    private extractArtifactContent(container: HTMLElement): string {
        // Try to find a code element first
        const codeElement = container.querySelector('pre code');
        if (codeElement) {
            return codeElement.textContent || '';
        }

        // Try pre element next
        const preElement = container.querySelector('pre');
        if (preElement) {
            return preElement.textContent || '';
        }

        // For SVGs, get the innerHTML of the SVG element
        const svgElement = container.querySelector('svg');
        if (svgElement) {
            return svgElement.outerHTML || '';
        }

        // For other types, get all text content
        return container.textContent || '';
    }

    /**
     * Extract metadata from an artifact container
     */
    private extractArtifactMetadata(container: HTMLElement): any {
        try {
            const metadataStr = container.dataset.artifactMetadata;
            if (metadataStr) {
                return JSON.parse(metadataStr);
            }
        } catch (error) {
            this.logger.error('EditorManager: Failed to parse artifact metadata', error);
        }
        return null;
    }

    /**
     * Detect the language from container classes or content
     */
    private detectLanguage(container: HTMLElement, content: string): string {
        // Check for code element with language class
        const codeElement = container.querySelector('pre code');
        if (codeElement) {
            const classNames = Array.from(codeElement.classList);
            const langClass = classNames.find(cls => cls.startsWith('language-'));
            if (langClass) {
                return langClass.replace('language-', '');
            }
        }

        // Check container classes
        if (container.classList.contains('code-artifact')) {
            // Try to extract language from class
            const classNames = Array.from(container.classList);
            const langClass = classNames.find(cls => cls.startsWith('language-'));
            if (langClass) {
                return langClass.replace('language-', '');
            }
        }

        // Check for SVG
        if (container.querySelector('svg') || content.trim().startsWith('<svg')) {
            return 'xml';
        }

        // Detect from content
        if (content.includes('function') || content.includes('const') || content.includes('var')) {
            return 'javascript';
        }

        if (content.includes('import ') && content.includes('from ')) {
            return 'typescript';
        }

        if (content.includes('def ') && content.includes(':')) {
            return 'python';
        }

        if (content.includes('<html>') || content.includes('<!DOCTYPE html>')) {
            return 'html';
        }

        if (content.includes('<style>') || content.includes('{') && content.includes('}')) {
            return 'css';
        }

        // Default to text
        return 'plaintext';
    }

    /**
     * Add a resize handle to the editor container
     */
    private addResizeHandle(editorContainer: HTMLElement, editor: monaco.editor.IStandaloneCodeEditor): void {
        const resizeHandle = document.createElement('div');
        resizeHandle.className = 'editor-resize-handle';
        Object.assign(resizeHandle.style, {
            height: '6px',
            background: '#e2e8f0',
            cursor: 'ns-resize',
            width: '100%',
            position: 'absolute',
            bottom: '0',
            left: '0',
            zIndex: '10'
        });

        editorContainer.appendChild(resizeHandle);
        editorContainer.style.position = 'relative';

        let startY = 0;
        let startHeight = 0;

        const onMouseDown = (e: MouseEvent) => {
            startY = e.clientY;
            startHeight = editorContainer.offsetHeight;

            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);

            e.preventDefault();
        };

        const onMouseMove = (e: MouseEvent) => {
            const newHeight = startHeight + (e.clientY - startY);
            if (newHeight >= 100) {
                editorContainer.style.height = `${newHeight}px`;
                editor.layout();
            }
        };

        const onMouseUp = () => {
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
        };

        resizeHandle.addEventListener('mousedown', onMouseDown);
    }

    /**
     * Save changes from the editor back to the artifact
     */
    public async saveChanges(container: HTMLElement): Promise<boolean> {
        const editor = this.editorMap.get(container);
        if (!editor) {
            this.logger.error('EditorManager: No editor found for this container');
            return false;
        }

        try {
            // Get updated content from editor
            const updatedContent = editor.getValue();

            // Find the original content element
            const preElement = container.querySelector('pre');
            const codeElement = container.querySelector('pre code');

            if (codeElement) {
                // Update code element content
                codeElement.textContent = updatedContent;
                // Show the original code element again
                if (preElement) {
                    preElement.style.display = '';
                }
            } else if (container.querySelector('svg')) {
                // Update SVG content - this is more complex
                try {
                    const svgContainer = container.querySelector('svg')?.parentElement;
                    if (svgContainer) {
                        svgContainer.innerHTML = updatedContent;
                    }
                } catch (e) {
                    this.logger.error('EditorManager: Failed to update SVG content', e);
                    this.bannerService.showError('Failed to update SVG: Invalid SVG syntax');
                    return false;
                }
            } else if (preElement) {
                // Update pre element content
                preElement.textContent = updatedContent;
                preElement.style.display = '';
            } else {
                // No suitable element found to update
                this.logger.warn('EditorManager: No suitable element found to update');
                this.bannerService.showWarning('Could not find element to update');
                return false;
            }

            // Remove editor
            this.removeEditor(container);

            // Show success message
            this.bannerService.showSuccess('Changes saved successfully');
            return true;
        } catch (error) {
            this.logger.error('EditorManager: Failed to save changes', error);
            this.bannerService.showError('Failed to save changes');
            return false;
        }
    }

    /**
     * Remove an editor from a container
     */
    public removeEditor(container: HTMLElement): void {
        const editor = this.editorMap.get(container);
        if (editor) {
            // Dispose of the editor
            editor.dispose();
            this.editorMap.delete(container);

            // Remove editor container
            const editorContainer = container.querySelector('.monaco-editor-container');
            editorContainer?.remove();

            // Remove editing mode class
            container.classList.remove('editing-mode');

            // Show any hidden elements
            container.querySelectorAll('pre').forEach(pre => {
                pre.style.display = '';
            });

            this.logger.debug('EditorManager: Removed editor');
        }
    }

    /**
     * Get the content of an editor
     */
    public getEditorContent(container: HTMLElement): string | null {
        const editor = this.editorMap.get(container);
        if (editor) {
            return editor.getValue();
        }
        return null;
    }

    /**
     * Dispose all editors
     */
    public disposeAll(): void {
        this.editorMap.forEach((editor, container) => {
            this.removeEditor(container);
        });
        this.editorMap.clear();
        this.logger.info('EditorManager: Disposed all editors');
    }
}


================================================================================
FILE: shared/filenameHelper.js
================================================================================

// Generates unique filenames based on directory structure preference
export function getUniqueFileName(
    title,
    language,
    messageIndex,
    usedNames,
    useDirectoryStructure,
) {
    let baseName = title.replace(/[^\w\-._]+/g, "_");
    let extension = getFileExtension(language);
    let fileName = useDirectoryStructure
        ? inferDirectoryStructure(baseName, extension)
        : `${messageIndex + 1}_${baseName}${extension}`;

    let suffix = "";
    let suffixCount = 1;
    while (usedNames.has(fileName + suffix)) {
        suffix = `_${"*".repeat(suffixCount++)}`;
    }

    fileName += suffix;
    usedNames.add(fileName);
    return fileName;
}

function inferDirectoryStructure(baseName, extension, messageIndex = null) {
    const parts = baseName.split("/");
    const fileName = parts.pop() + extension;
    const directory = parts.join("/");
    return messageIndex !== null
        ? `${directory}/${messageIndex + 1}_${fileName}`
        : `${directory}/${fileName}`;
}

function getFileExtension(language) {
    const map = {
        js: ".js", python: ".py", java: ".java", txt: ".txt",
        // add other languages as needed
    };
    return map[language.toLowerCase()] || ".txt";
}


================================================================================
FILE: shared/zipCreator.js
================================================================================

// Creates a JSZip instance and returns blob asynchronously
export async function createZip(artifacts) {
    const zip = new JSZip();
    artifacts.forEach(({ filename, content }) => {
        zip.file(filename, content);
    });
    return zip.generateAsync({ type: "blob" });
}


================================================================================
FILE: shared/artifactExtractor.js
================================================================================

// Extract artifacts from Claude's responses
export function extractArtifacts(text) {
    const artifactRegex = /<antArtifact[^>]*>([\s\S]*?)<\/antArtifact>/g;
    const artifacts = [];
    let match;

    while ((match = artifactRegex.exec(text)) !== null) {
        const fullTag = match[0];
        const content = match[1];

        const titleMatch = fullTag.match(/title="([^"]*)/);
        const languageMatch = fullTag.match(/language="([^"]*)/);

        artifacts.push({
            title: titleMatch ? titleMatch[1] : "Untitled",
            language: languageMatch ? languageMatch[1] : "txt",
            content: content.trim(),
        });
    }

    return artifacts;
}


================================================================================
FILE: shared/utils/artifactExtractor.ts
================================================================================

import { Artifact, ArtifactType } from '../models/artifact';
import { LoggerService } from '../services/loggerService';

/**
 * Utility for extracting artifacts from Claude responses
 */
export class ArtifactExtractor {
    private static readonly logger = LoggerService.getInstance();

    /**
     * Extract artifacts from HTML DOM
     */
    public static extractArtifactsFromDOM(containerSelector: string = '.conversation-container'): Artifact[] {
        try {
            const container = document.querySelector(containerSelector);
            if (!container) {
                this.logger.warn('ArtifactExtractor: Container not found');
                return [];
            }

            const artifacts: Artifact[] = [];

            // Find all artifact containers
            const artifactContainers = container.querySelectorAll('.antml-artifact-container');

            artifactContainers.forEach((container: Element, index: number) => {
                try {
                    const artifact = this.extractArtifactFromContainer(container as HTMLElement);
                    if (artifact) {
                        artifacts.push(artifact);
                    }
                } catch (error) {
                    this.logger.error(`ArtifactExtractor: Error extracting artifact at index ${index}`, error);
                }
            });

            return artifacts;
        } catch (error) {
            this.logger.error('ArtifactExtractor: Error extracting artifacts from DOM', error);
            return [];
        }
    }

    /**
     * Extract an artifact from a container element
     */
    private static extractArtifactFromContainer(container: HTMLElement): Artifact | null {
        if (!container) return null;

        try {
            // Extract title
            const titleElement = container.querySelector('.antml-artifact-title');
            const title = titleElement?.textContent?.trim() || 'Untitled Artifact';

            // Generate ID
            const id = `artifact-${Date.now()}-${Math.floor(Math.random() * 1000)}`;

            // Determine type and extract content
            let type = ArtifactType.UNKNOWN;
            let content = '';
            let language: string | undefined;

            // Check for code artifact
            const codeElement = container.querySelector('pre code');
            if (codeElement) {
                type = ArtifactType.CODE;
                content = codeElement.textContent || '';

                // Try to get language from class
                const classNames = Array.from(codeElement.classList);
                const langClass = classNames.find(cls => cls.startsWith('language-'));
                if (langClass) {
                    language = langClass.replace('language-', '');
                }
            }
            // Check for SVG
            else if (container.querySelector('svg')) {
                type = ArtifactType.SVG;
                const svgElement = container.querySelector('svg');
                content = svgElement?.outerHTML || '';
            }
            // Check for Mermaid
            else if (container.classList.contains('mermaid-artifact')) {
                type = ArtifactType.MERMAID;
                content = container.textContent || '';
            }
            // Check for React
            else if (container.classList.contains('react-artifact')) {
                type = ArtifactType.REACT;
                content = container.textContent || '';
            }
            // Check for HTML
            else if (container.classList.contains('html-artifact')) {
                type = ArtifactType.HTML;
                content = container.querySelector('div')?.innerHTML || '';
            }
            // Default to Markdown for text
            else {
                type = ArtifactType.MARKDOWN;
                content = container.textContent || '';
            }

            return {
                id,
                title,
                content,
                type,
                language,
                timestamp: new Date().toISOString()
            };
        } catch (error) {
            this.logger.error('ArtifactExtractor: Error extracting artifact from container', error);
            return null;
        }
    }

    /**
     * Stitch together artifacts with the same title and type
     */
    public static stitchArtifacts(artifacts: Artifact[]): Artifact[] {
        if (!artifacts || artifacts.length <= 1) return artifacts;

        try {
            const stitchedArtifacts: Artifact[] = [];
            const artifactGroups = new Map<string, Artifact[]>();

            // Group artifacts by title and type
            artifacts.forEach(artifact => {
                const key = `${artifact.title}-${artifact.type}${artifact.language ? `-${artifact.language}` : ''}`;

                if (!artifactGroups.has(key)) {
                    artifactGroups.set(key, []);
                }

                artifactGroups.get(key)?.push(artifact);
            });

            // Process each group
            artifactGroups.forEach((group, key) => {
                if (group.length === 1) {
                    // Single artifact, no stitching needed
                    stitchedArtifacts.push(group[0]);
                } else {
                    // Multiple artifacts with same title, stitch them
                    this.logger.info(`ArtifactExtractor: Stitching ${group.length} artifacts for key: ${key}`);

                    // Sort by timestamp if available
                    group.sort((a, b) => {
                        if (a.timestamp && b.timestamp) {
                            return new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime();
                        }
                        return 0;
                    });

                    // Combine content
                    const stitched: Artifact = {
                        ...group[0],
                        content: group.map(a => a.content).join('\n'),
                        partOfSeries: true,
                        seriesPosition: 1,
                        seriesTotal: group.length
                    };

                    stitchedArtifacts.push(stitched);
                }
            });

            return stitchedArtifacts;
        } catch (error) {
            this.logger.error('ArtifactExtractor: Error stitching artifacts', error);
            return artifacts;
        }
    }
}


================================================================================
FILE: shared/utils/filenameHelper.ts
================================================================================

import { Artifact } from '../models/artifact';
import { LoggerService } from '../services/loggerService';

/**
 * Helper for generating filenames for artifacts
 */
export class FilenameHelper {
    private static readonly logger = LoggerService.getInstance();

    /**
     * Map artifact types to appropriate file extensions
     */
    private static readonly extensionMap: Record<string, string> = {
        code: '', // determined by language
        markdown: '.md',
        html: '.html',
        svg: '.svg',
        mermaid: '.mmd',
        react: '.jsx',
        unknown: '.txt'
    };

    /**
     * Map language to file extensions
     */
    private static readonly languageExtensionMap: Record<string, string> = {
        javascript: '.js',
        typescript: '.ts',
        python: '.py',
        java: '.java',
        csharp: '.cs',
        cpp: '.cpp',
        c: '.c',
        ruby: '.rb',
        go: '.go',
        php: '.php',
        sql: '.sql',
        rust: '.rs',
        swift: '.swift',
        kotlin: '.kt',
        scala: '.scala',
        dart: '.dart',
        json: '.json',
        yaml: '.yaml',
        xml: '.xml',
        css: '.css',
        scss: '.scss',
        less: '.less',
        bash: '.sh',
        powershell: '.ps1',
        plaintext: '.txt'
    };

    /**
     * Get a safe filename for an artifact
     */
    public static getFilename(
        artifact: Artifact,
        includeTimestamp: boolean = true,
        replaceInvalidChars: boolean = true,
        maxLength: number = 255
    ): string {
        try {
            // Start with artifact title
            let filename = artifact.title || 'untitled';

            // Add timestamp if requested
            if (includeTimestamp && artifact.timestamp) {
                const date = new Date(artifact.timestamp);
                const timestamp = date.toISOString().replace(/[:.]/g, '-').slice(0, 19);
                filename = `${filename}_${timestamp}`;
            }

            // Make filename safe
            if (replaceInvalidChars) {
                filename = this.sanitizeFilename(filename, true);
            } else {
                filename = this.sanitizeFilename(filename, false);
            }

            // Add appropriate extension
            const extension = this.getExtension(artifact);

            // Ensure filename is not too long
            const maxBaseLength = maxLength - extension.length;
            if (filename.length > maxBaseLength) {
                filename = filename.slice(0, maxBaseLength);
            }

            return `${filename}${extension}`;
        } catch (error) {
            this.logger.error('FilenameHelper: Error generating filename', error);
            return `artifact-${Date.now()}.txt`;
        }
    }

    /**
     * Get file extension for an artifact
     */
    private static getExtension(artifact: Artifact): string {
        if (artifact.type === 'code' && artifact.language) {
            return this.languageExtensionMap[artifact.language.toLowerCase()] || '.txt';
        }

        return this.extensionMap[artifact.type] || '.txt';
    }

    /**
     * Sanitize a filename to be safe for file systems
     */
    private static sanitizeFilename(name: string, replaceChars: boolean = true): string {
        // Remove or replace unsafe characters
        if (replaceChars) {
            // Replace unsafe characters with underscores
            return name
                .replace(/[<>:"/\\|?*]/g, '_') // Replace Windows unsafe chars
                .replace(/\s+/g, '_')          // Replace spaces with underscores
                .replace(/\.\./g, '_')         // Replace .. to prevent directory traversal
                .replace(/^[.-]+/, '')         // Remove leading dots and dashes
                .replace(/[.-]+$/, '');        // Remove trailing dots and dashes
        } else {
            // Remove unsafe characters
            return name
                .replace(/[<>:"/\\|?*]/g, '')  // Remove Windows unsafe chars
                .replace(/\s+/g, '_')          // Replace spaces with underscores
                .replace(/\.\./g, '_')         // Replace .. to prevent directory traversal
                .replace(/^[.-]+/, '')         // Remove leading dots and dashes
                .replace(/[.-]+$/, '');        // Remove trailing dots and dashes
        }
    }

    /**
     * Generate folder path for an artifact in structured storage
     */
    public static getFolderPath(artifact: Artifact, conversationTitle?: string): string {
        try {
            // Get date from artifact timestamp or current time
            const date = artifact.timestamp ? new Date(artifact.timestamp) : new Date();

            // Format year and month
            const year = date.getFullYear();
            const month = (date.getMonth() + 1).toString().padStart(2, '0');

            // Base path using date
            let path = `${year}/${month}`;

            // Add conversation title if available
            if (conversationTitle) {
                const safeFolderName = this.sanitizeFilename(conversationTitle);
                path = `${path}/${safeFolderName}`;
            }

            return path;
        } catch (error) {
            this.logger.error('FilenameHelper: Error generating folder path', error);
            return 'artifacts';
        }
    }
}


================================================================================
FILE: shared/utils/zipCreator.ts
================================================================================

import { ArtifactFile } from '../models/artifact';
import { LoggerService } from '../services/loggerService';

/**
 * Helper for creating ZIP archives of artifacts
 */
export class ZipCreator {
    private static readonly logger = LoggerService.getInstance();

    /**
     * Create a ZIP file from a list of artifact files
     */
    public static async createZip(files: ArtifactFile[]): Promise<Blob> {
        try {
            // Ensure JSZip is loaded
            const JSZip = await this.loadJSZip();

            // Create a new ZIP archive
            const zip = new JSZip();

            // Add files to the ZIP
            for (const file of files) {
                const path = file.path ? `${file.path}/${file.filename}` : file.filename;

                // Add content to ZIP (Blob or string)
                if (file.content instanceof Blob) {
                    zip.file(path, file.content);
                } else {
                    zip.file(path, file.content);
                }
            }

            // Generate ZIP file
            const zipBlob = await zip.generateAsync({
                type: 'blob',
                compression: 'DEFLATE',
                compressionOptions: {
                    level: 9
                }
            });

            return zipBlob;
        } catch (error) {
            this.logger.error('ZipCreator: Error creating ZIP file', error);
            throw error;
        }
    }

    /**
     * Load JSZip library from CDN if not already loaded
     */
    private static async loadJSZip(): Promise<typeof JSZip> {
        // Check if JSZip is already loaded
        if ((window as any).JSZip) {
            return (window as any).JSZip;
        }

        // Load JSZip from CDN
        this.logger.debug('ZipCreator: Loading JSZip from CDN');

        return new Promise<typeof JSZip>((resolve, reject) => {
            const script = document.createElement('script');
            script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
            script.onload = () => {
                this.logger.debug('ZipCreator: JSZip loaded successfully');
                resolve((window as any).JSZip);
            };
            script.onerror = () => {
                const error = new Error('Failed to load JSZip library');
                this.logger.error('ZipCreator: JSZip load error', error);
                reject(error);
            };
            document.head.appendChild(script);
        });
    }
}


================================================================================
FILE: shared/models/editor.ts
================================================================================

/**
 * Types related to the Monaco Editor integration
 */

export interface IEditorInstance {
    id: string;
    editor: monaco.editor.IStandaloneCodeEditor;
    language: string;
    originalContent: string;
    isDirty: boolean;
}

export interface ICompilationResult {
    success: boolean;
    output?: string;
    error?: string;
    language: string;
    executionTime?: number;
}

export interface IEditorOptions {
    theme?: string;
    fontSize?: number;
    wordWrap?: 'on' | 'off';
    lineNumbers?: 'on' | 'off';
    minimap?: {
        enabled: boolean;
    };
}

export interface IMonacoEditorService {
    /**
     * Initialize the Monaco Editor
     * @returns Promise that resolves when initialization is complete
     */
    initialize(): Promise<void>;

    /**
     * Create a new editor instance
     * @param container DOM element to contain the editor
     * @param content Initial content
     * @param language Programming language
     * @param id Unique identifier for the editor
     * @param options Editor options
     */
    createEditor(
        container: HTMLElement,
        content: string,
        language: string,
        id: string,
        options?: IEditorOptions
    ): Promise<monaco.editor.IStandaloneCodeEditor | null>;

    /**
     * Get content from an editor
     * @param id Editor ID
     */
    getContent(id: string): string | null;

    /**
     * Update the content of an editor
     * @param id Editor ID
     * @param content New content
     */
    updateContent(id: string, content: string): boolean;

    /**
     * Dispose of an editor instance
     * @param id Editor ID
     */
    disposeEditor(id: string): void;

    /**
     * Dispose of all editor instances
     */
    disposeAll(): void;

    /**
     * Check if an editor with the given ID exists
     * @param id Editor ID
     */
    hasEditor(id: string): boolean;
}

export interface ICompilerService {
    /**
     * Compile and run code
     * @param code The code to compile/run
     * @param language The programming language
     */
    compileAndRun(code: string, language: string): Promise<ICompilationResult>;

    /**
     * Check if a language is supported for compilation
     * @param language The programming language to check
     */
    isLanguageSupported(language: string): boolean;
}


================================================================================
FILE: shared/models/settings.ts
================================================================================

/**
 * Settings model for the Claude Artifacts extension
 */

/**
 * Main settings interface for artifact handling
 */
export interface ArtifactSettings {
    /**
     * Whether to automatically combine artifacts with the same title/type that may have been split
     * due to Claude response limitations
     */
    stitchArtifacts: boolean;

    /**
     * Whether to save all files in a flat structure (true) or organize by conversation/date (false)
     */
    flatFileStructure: boolean;

    /**
     * Whether to include the timestamp in filenames
     */
    includeTimestampInFilename: boolean;

    /**
     * Whether to replace invalid filename characters (true) or just remove them (false)
     */
    replaceInvalidChars: boolean;

    /**
     * Maximum filename length (including extension)
     */
    maxFilenameLength: number;

    /**
     * API-related settings
     */
    apiSettings: ApiSettings;

    /**
     * Monaco editor settings
     */
    editorSettings: EditorSettings;

    /**
     * Compiler settings
     */
    compilerSettings: CompilerSettings;

    /**
     * UI settings
     */
    uiSettings: UISettings;

    /**
     * The version of the settings schema, for handling migrations
     */
    version: number;
}

/**
 * Settings for Claude API access
 */
export interface ApiSettings {
    /**
     * Whether to enable API continuation when rate limited
     */
    enableApiContinuation: boolean;

    /**
     * Claude API key (stored encrypted)
     */
    apiKey: string;

    /**
     * API endpoint for Claude conversations
     */
    apiEndpoint: string;

    /**
     * The model to use for API requests
     */
    modelName: string;

    /**
     * Max tokens to generate in API responses
     */
    maxTokens: number;

    /**
     * Temperature setting for API requests
     */
    temperature: number;
}

/**
 * Settings for the Monaco code editor
 */
export interface EditorSettings {
    /**
     * Theme for the Monaco editor
     */
    theme: 'vs' | 'vs-dark' | 'hc-black';

    /**
     * Font size for the editor
     */
    fontSize: number;

    /**
     * Line numbers visibility
     */
    lineNumbers: 'on' | 'off' | 'relative';

    /**
     * Word wrap settings
     */
    wordWrap: 'off' | 'on' | 'wordWrapColumn' | 'bounded';

    /**
     * Whether to enable minimap
     */
    minimap: boolean;

    /**
     * Tab size
     */
    tabSize: number;

    /**
     * Insert spaces when pressing Tab
     */
    insertSpaces: boolean;

    /**
     * Whether to enable auto bracket pairs
     */
    autoClosingBrackets: boolean;

    /**
     * Whether to auto indent when pressing Enter
     */
    autoIndent: boolean;

    /**
     * Whether to enable code folding
     */
    folding: boolean;

    /**
     * Whether to automatically load editor for all code artifacts
     */
    autoLoadForCode: boolean;
}

/**
 * Settings for the code compiler/runner
 */
export interface CompilerSettings {
    /**
     * Whether to enable the code compilation feature
     */
    enableCompilation: boolean;

    /**
     * Whether to use a local sandbox or remote compilation service
     */
    useRemoteCompilation: boolean;

    /**
     * Endpoint for remote compilation if enabled
     */
    remoteCompilationEndpoint: string;

    /**
     * Timeout in milliseconds for code execution
     */
    executionTimeoutMs: number;

    /**
     * Whether to show line numbers in compiler output
     */
    showLineNumbers: boolean;

    /**
     * Whether to show execution time in compiler output
     */
    showExecutionTime: boolean;

    /**
     * Languages supported for compilation
     */
    supportedLanguages: string[];

    /**
     * API key for remote compilation service (stored encrypted)
     */
    compilationApiKey: string;
}

/**
 * Settings for UI customization
 */
export interface UISettings {
    /**
     * Whether to show the download button
     */
    showDownloadButton: boolean;

    /**
     * Whether to show the settings button
     */
    showSettingsButton: boolean;

    /**
     * Whether to show the edit button on artifacts
     */
    showEditButton: boolean;

    /**
     * Whether to show the run button on code artifacts
     */
    showRunButton: boolean;

    /**
     * Whether to show success/error notifications
     */
    showNotifications: boolean;

    /**
     * Duration in milliseconds to show notifications
     */
    notificationDurationMs: number;

    /**
     * Whether to show confirmation dialogs for actions
     */
    showConfirmations: boolean;

    /**
     * Custom CSS for UI elements
     */
    customCSS: string;
}

/**
 * UI element references used internally
 */
export interface UIElements {
    downloadButton: HTMLButtonElement | null;
    settingsButton: HTMLButtonElement | null;
    headerContainer: HTMLElement | null;
}

/**
 * Default settings object
 */
export const DEFAULT_SETTINGS: ArtifactSettings = {
    stitchArtifacts: true,
    flatFileStructure: false,
    includeTimestampInFilename: true,
    replaceInvalidChars: true,
    maxFilenameLength: 255,
    apiSettings: {
        enableApiContinuation: false,
        apiKey: '',
        apiEndpoint: 'https://api.anthropic.com/v1/messages',
        modelName: 'claude-3-haiku-20240307',
        maxTokens: 4096,
        temperature: 0.7
    },
    editorSettings: {
        theme: 'vs',
        fontSize: 14,
        lineNumbers: 'on',
        wordWrap: 'on',
        minimap: true,
        tabSize: 2,
        insertSpaces: true,
        autoClosingBrackets: true,
        autoIndent: true,
        folding: true,
        autoLoadForCode: false
    },
    compilerSettings: {
        enableCompilation: true,
        useRemoteCompilation: true,
        remoteCompilationEndpoint: 'https://api.compilers.io',
        executionTimeoutMs: 5000,
        showLineNumbers: true,
        showExecutionTime: true,
        supportedLanguages: [
            'javascript', 'typescript', 'python', 'java', 'c', 'cpp', 'csharp',
            'go', 'rust', 'php', 'ruby', 'swift', 'kotlin', 'scala'
        ],
        compilationApiKey: ''
    },
    uiSettings: {
        showDownloadButton: true,
        showSettingsButton: true,
        showEditButton: true,
        showRunButton: true,
        showNotifications: true,
        notificationDurationMs: 3000,
        showConfirmations: true,
        customCSS: ''
    },
    version: 1
};


================================================================================
FILE: shared/models/artifact.ts
================================================================================

/**
 * Types of artifacts that can be extracted from Claude responses
 */
export enum ArtifactType {
    CODE = 'code',
    MARKDOWN = 'markdown',
    HTML = 'html',
    SVG = 'svg',
    MERMAID = 'mermaid',
    REACT = 'react',
    UNKNOWN = 'unknown'
}

/**
 * Interface for an extracted artifact from Claude
 */
export interface Artifact {
    /**
     * Unique identifier for the artifact
     */
    id: string;

    /**
     * Display title of the artifact
     */
    title: string;

    /**
     * Content of the artifact
     */
    content: string;

    /**
     * Type of the artifact
     */
    type: ArtifactType;

    /**
     * Programming language for code artifacts
     */
    language?: string;

    /**
     * Timestamp when the artifact was extracted
     */
    timestamp: string;

    /**
     * Conversation ID this artifact belongs to
     */
    conversationId?: string;

    /**
     * Message ID this artifact belongs to
     */
    messageId?: string;

    /**
     * Whether this artifact is part of a series that needs stitching
     */
    partOfSeries?: boolean;

    /**
     * Position in the series if part of one
     */
    seriesPosition?: number;

    /**
     * Total number of parts in the series
     */
    seriesTotal?: number;
}

/**
 * Interface for artifact file information for downloading
 */
export interface ArtifactFile {
    /**
     * Filename to use for the artifact
     */
    filename: string;

    /**
     * Content of the file
     */
    content: string | Blob;

    /**
     * Path within the archive (for structured organization)
     */
    path?: string;

    /**
     * Original artifact reference
     */
    artifact: Artifact;
}

/**
 * Information about a conversation that contains artifacts
 */
export interface ConversationInfo {
    /**
     * Unique ID of the conversation
     */
    id: string;

    /**
     * Title of the conversation
     */
    title: string;

    /**
     * Timestamp of the conversation
     */
    timestamp: string;

    /**
     * Number of artifacts in the conversation
     */
    artifactCount: number;
}


================================================================================
FILE: shared/services/loggerService.ts
================================================================================

/**
 * Logger service for consistent logging throughout the extension
 */
export enum LogLevel {
    DEBUG = 0,
    INFO = 1,
    WARN = 2,
    ERROR = 3,
    NONE = 4
}

/**
 * Service for logging messages at different levels with consistent formatting
 */
export class LoggerService {
    private static instance: LoggerService;
    private logLevel: LogLevel = LogLevel.INFO;
    private readonly prefix = '[Claude Artifacts]';
    private readonly isProduction = process.env.NODE_ENV === 'production';

    private constructor() {
        // Private constructor for singleton
        if (this.isProduction) {
            this.logLevel = LogLevel.WARN;
        }
    }

    /**
     * Get the singleton instance of the logger
     */
    public static getInstance(): LoggerService {
        if (!LoggerService.instance) {
            LoggerService.instance = new LoggerService();
        }
        return LoggerService.instance;
    }

    /**
     * Set the minimum log level to display
     */
    public setLogLevel(level: LogLevel): void {
        this.logLevel = level;
    }

    /**
     * Log a debug message
     */
    public debug(message: string, ...args: any[]): void {
        if (this.logLevel <= LogLevel.DEBUG) {
            console.debug(`${this.prefix} ${message}`, ...args);
        }
    }

    /**
     * Log an info message
     */
    public info(message: string, ...args: any[]): void {
        if (this.logLevel <= LogLevel.INFO) {
            console.info(`${this.prefix} ${message}`, ...args);
        }
    }

    /**
     * Log a warning message
     */
    public warn(message: string, ...args: any[]): void {
        if (this.logLevel <= LogLevel.WARN) {
            console.warn(`${this.prefix} ${message}`, ...args);
        }
    }

    /**
     * Log an error message
     */
    public error(message: string, ...args: any[]): void {
        if (this.logLevel <= LogLevel.ERROR) {
            console.error(`${this.prefix} ${message}`, ...args);
        }
    }

    /**
     * Create a group in the console for related logs
     */
    public group(label: string): void {
        if (this.logLevel < LogLevel.NONE) {
            console.group(`${this.prefix} ${label}`);
        }
    }

    /**
     * End a console group
     */
    public groupEnd(): void {
        if (this.logLevel < LogLevel.NONE) {
            console.groupEnd();
        }
    }

    /**
     * Measure performance between points
     */
    public time(label: string): void {
        if (this.logLevel <= LogLevel.DEBUG) {
            console.time(`${this.prefix} ${label}`);
        }
    }

    /**
     * End performance measurement
     */
    public timeEnd(label: string): void {
        if (this.logLevel <= LogLevel.DEBUG) {
            console.timeEnd(`${this.prefix} ${label}`);
        }
    }
}

